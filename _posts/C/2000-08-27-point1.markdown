---
layout: post
title:  "指针示例(int *)"
categories: c_language
---

### C 语言中指针的用法及内存布局示例（基于 64 位系统）

#### 示例代码

```c
#include <stdio.h>

int main() {
    int a = 0x12345678;  // 定义一个 int 类型变量 a，值为 0x12345678
    int *p = &a;         // 定义一个指向 int 类型的指针 p，并将 a 的地址赋给 p
    /**
     * 这里 *p = &a; 其实是干了两件事   
     * 1. 定义一个指针变量 int *p; 也可以写成int* p;这样更容易理解，就是一个指向int的指针
     * 2. 给指针赋初值 p = &a;
     */

    printf("a = 0x%x\n", a);       // 输出 a 的值
    printf("*p = 0x%x\n", *p);     // 输出 p 指向的值 (解引用 p)

    return 0;
}
```

在这个例子中，`a` 是一个 `int` 类型的变量，值为 `0x12345678`，`p` 是指向 `a` 的指针。我们将通过 64 位系统的内存布局展示指针的取值和赋值过程。

### 1. 内存布局假设

- 假设变量 `a` 的内存地址为 `0x1000`，它占用 **4 个单位**（每个单位对应一个字节）。
- 假设指针 `p` 的内存地址为 `0x2000`，它占用 **8 个单位**（64 位系统中指针大小为 8 个单位）。

### 2. 内存布局表格

我们按照从高到低的顺序展示 `a` 和 `p` 在内存中的内容。

| 地址          | 内容        | 说明                           |
|---------------|-------------|--------------------------------|
| `0x2007`      | `00`        | 指针 `p` 的高位                |
| `0x2006`      | `00`        |                                |
| `0x2005`      | `00`        |                                |
| `0x2004`      | `00`        |                                |
| `0x2003`      | `00`        |                                |
| `0x2002`      | `00`        |                                |
| `0x2001`      | `10`        | `p` 指向的地址 `0x1000` 的高位 |
| `0x2000`      | `00`        | `p` 指向的地址 `0x1000` 的低位 |
|               |             |                                |
| `0x1003`      | `12`        | 变量 `a` 的最高位（`0x12`）    |
| `0x1002`      | `34`        |                                |
| `0x1001`      | `56`        |                                |
| `0x1000`      | `78`        | 变量 `a` 的最低位（`0x78`）    |

### 3. 详细解释指针的用法

#### 1. **定义变量和指针**

```c
int a = 0x12345678;
int *p = &a;
```

- **`a` 的定义**：在内存地址 `0x1000` 开始的 4 个单位中，存储值 `0x12345678`。
- **`p` 的定义**：指针 `p` 指向变量 `a` 的地址 `0x1000`，`p` 占用 8 个单位。

##### 内存中的 `a`

变量 `a` 的值 `0x12345678` 存储在地址 `0x1000` 开始的 4 个单位中：

- 地址 `0x1003`：`12`（`0x12345678` 的最高位）
- 地址 `0x1002`：`34`
- 地址 `0x1001`：`56`
- 地址 `0x1000`：`78`（`0x12345678` 的最低位）

##### 内存中的 `p`

指针 `p` 存储在地址 `0x2000` 开始的 8 个单位中，存储的是 `a` 的地址 `0x1000`：

- 地址 `0x2007` 至 `0x2004`：`00`，因为地址 `0x1000` 只用到了低 4 位，所以高位全为 `0`。
- 地址 `0x2003`：`00`
- 地址 `0x2002`：`00`
- 地址 `0x2001`：`10`（`0x1000` 的高位）
- 地址 `0x2000`：`00`（`0x1000` 的低位）

#### 2. **指针的取值（解引用）**

```c
printf("*p = 0x%x\n", *p);
```

- **`*p`** 是对指针 `p` 的解引用，表示访问指针 `p` 指向的内存地址 `0x1000` 中存储的值。
- 在内存地址 `0x1000`，存储的值为 `0x12345678`，因此 `*p` 的值为 `0x12345678`。

##### 内存操作

1. 读取 `p` 的内容，发现 `p` 指向地址 `0x1000`。
2. 访问地址 `0x1000` 中的内容，读取 `0x12345678`。

#### 3. **指针修改值**

通过指针可以修改它指向的变量的值，虽然本示例未直接修改值，但可以通过指针 `p` 修改 `a` 的值，如下：

```c
*p = 0x87654321;  // 修改指针 p 指向的值，即 a 的值
```

- `*p = 0x87654321;` 修改指针 `p` 指向的变量 `a` 的值为 `0x87654321`。
- 修改后的 `a` 的值会存储在地址 `0x1000` 处。

##### 修改后的内存布局

| 地址          | 内容        | 说明                           |
|---------------|-------------|--------------------------------|
| `0x2007`      | `00`        | 指针 `p` 的高位                |
| `0x2006`      | `00`        |                                |
| `0x2005`      | `00`        |                                |
| `0x2004`      | `00`        |                                |
| `0x2003`      | `00`        |                                |
| `0x2002`      | `00`        |                                |
| `0x2001`      | `10`        | `p` 指向的地址 `0x1000` 的高位 |
| `0x2000`      | `00`        | `p` 指向的地址 `0x1000` 的低位 |
|               |             |                                |
| `0x1003`      | `87`        | 变量 `a` 的最高位（`0x87`）    |
| `0x1002`      | `65`        |                                |
| `0x1001`      | `43`        |                                |
| `0x1000`      | `21`        | 变量 `a` 的最低位（`0x21`）    |

- 地址 `0x1000` 处的内容由 `0x12345678` 变为 `0x87654321`。

#### 4. 输出修改后的值

通过指针修改值后，直接访问变量 `a`，输出的值将是 `0x87654321`。

```c
printf("a = 0x%x\n", a);
```

### 4. 指针的用法总结

#### 1. **定义与初始化**

```c
int *p;
p = &a;
```

- 指针 `p` 用来存储变量 `a` 的地址。通过 `p = &a;`，指针 `p` 存储了 `a` 的内存地址 `0x1000`。

#### 2. **解引用指针**

```c
int value = *p;
```

- 通过 `*p` 访问 `p` 指向的内存地址中存储的值。即 `*p` 取出了地址 `0x1000` 处的值 `0x12345678`。

#### 3. **通过指针修改值**

```c
*p = 0x87654321;
```

- 通过解引用操作符 `*` 修改 `p` 指向的变量的值。`*p = 0x87654321;` 实际上修改了 `a` 的值为 `0x87654321`，并存储在地址 `0x1000`。

#### 4. **内存布局与指针的关系**

- 在 64 位系统中，指针占用 8 个单位，`int` 类型通常占用 4 个单位。
- 指针存储的是变量的地址，而不是变量的值。解引用指针 `*p` 可以访问和修改指向的变量的值。
- 内存布局是从高地址到低地址排列，指针的高位存储在高地址，低位存储在低地址。
