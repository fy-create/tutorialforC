---
layout: post
title:  "C语言关键字和储存类型(auto,static,extern,register)"
categories: c_language
---

### C 语言的全部关键字（按类型、程序流程、其他分类）

#### 1. **数据类型相关关键字**
这些关键字用于定义数据类型：

- `char`：字符类型。
- `int`：整型。
- `float`：浮点型。
- `double`：双精度浮点型。
- `void`：空类型，表示函数无返回值或指针指向空类型。
- `short`：短整型。
- `long`：长整型。
- `signed`：有符号类型。
- `unsigned`：无符号类型。
- `enum`：枚举类型。
- `struct`：结构体。
- `union`：联合体。

#### 2. **程序流程控制关键字**
这些关键字用于控制程序的流程：

- `if`：条件语句。
- `else`：条件语句的分支部分。
- `switch`：选择语句。
- `case`：用于 switch 语句的分支。
- `default`：switch 语句的默认分支。
- `while`：条件循环。
- `for`：循环语句。
- `do`：do-while 循环。
- `break`：跳出循环或 switch 语句。
- `continue`：跳过本次循环，进入下一个循环。
- `goto`：跳转语句，跳转到标签位置。
- `return`：函数返回语句。

#### 3. **存储类型修饰符**
这些关键字用于指定变量的存储类型：

- `auto`：自动变量（局部变量的默认存储类型）。
- `static`：静态变量，生命周期是程序的整个执行过程。
- `extern`：表示外部变量或函数，作用域可跨文件。
- `register`：提示编译器将变量存储在寄存器中，而不是内存中。

#### 4. **其他关键字**
这些关键字与程序的其他功能相关：

- `const`：常量修饰符，表示变量不可修改。
- `volatile`：表示变量可能被外部因素修改，编译器不会对其优化。
- `typedef`：为已有类型定义新的别名。
- `sizeof`：用于获取数据类型或变量的大小。
- `extern`：声明外部变量或函数，指明其在其他文件中定义。
- `inline`：提示编译器将函数在调用处展开，以提高执行效率。
- `typedef`：定义类型别名。



---

### 解释储存类型修饰符 (`auto`, `static`, `extern`, `register`)

在 C 语言中，储存类型修饰符用于控制变量的 **存储方式**、**存储位置**、**生命周期** 和 **作用域**。

#### 1. `auto`
- **存储位置**：自动存储（通常在栈中）。
- **生命周期**：仅在定义的作用域内（如函数或代码块内）。函数退出后，自动变量就会被销毁。
- **作用域**：局部变量的作用域是其所在的函数或代码块。
- **默认行为**：`auto` 是局部变量的默认存储类型，因此几乎不需要显式使用。

**例子**：
```c
void func() {
    auto int a = 10;  // 等价于 int a = 10;
}
```
`auto` 的作用是声明局部变量，该变量在函数退出时自动销毁。

#### 2. `static`
- **存储位置**：静态存储区（内存的全局数据区）。
- **生命周期**：在程序的整个执行期间，变量的存储空间不会被释放，即使它在函数中定义，函数退出后变量仍然存在。
- **作用域**：
  - **局部静态变量**：只在其所在的函数或代码块内可见，但生命周期与程序相同。
  - **全局静态变量**：仅限于定义它的文件（即文件作用域），无法被其他文件访问。
- **默认初始化**：未初始化的静态变量默认初始化为 0。

**局部静态变量例子**：
```c
void func() {
    static int count = 0;  // 静态局部变量
    count++;
    printf("%d\n", count);
}

int main() {
    func();  // 输出 1
    func();  // 输出 2
}
```
这里 `count` 变量在 `func()` 函数内每次调用时会保留上一次的值。

**全局静态变量例子**：
```c
static int global_var = 100;  // 该变量只能在当前文件中访问
```

#### 3. `extern`
- **存储位置**：静态存储区。
- **生命周期**：在程序的整个执行期间。
- **作用域**：在声明它的文件中可见（全局变量）。通过 `extern` 可以在多个文件之间共享变量。
- **用途**：`extern` 用于声明一个外部变量或函数，表示该变量/函数在其他文件中定义。它可以使全局变量或函数在其他文件中可见。

**例子**：
假设在一个文件中定义了一个全局变量：
```c
// file1.c
int global_var = 10;
```
在另一个文件中可以通过 `extern` 访问它：
```c
// file2.c
extern int global_var;
```

#### 4. `register`
- **存储位置**：寄存器（如果编译器允许）。
- **生命周期**：与局部变量相同，在函数或代码块中有效，函数退出后变量销毁。
- **作用域**：局部作用域。
- **用途**：`register` 提示编译器将变量存储在 CPU 的寄存器中而不是内存中，以提高访问速度。但是，是否将变量放入寄存器由编译器决定，不是强制要求。
- **注意**：不能对 `register` 变量取地址，因为寄存器变量不在内存中。

**例子**：
```c
void func() {
    register int fast_var = 0;  // 尝试将变量存储在寄存器中
}
```

---

### 总结

| 修饰符  | 存储位置          | 生命周期                   | 作用域                       | 默认初始化  | 用途                      |
|---------|------------------|----------------------------|------------------------------|-------------|---------------------------|
| `auto`  | 栈                | 局部，函数结束时销毁        | 函数或代码块内               | 未初始化    | 局部变量（默认）           |
| `static`| 静态存储区        | 程序执行期间一直存在        | 局部或文件内（静态全局变量） | 默认 0      | 持久化局部变量，限制全局变量作用域 |
| `extern`| 静态存储区        | 程序执行期间一直存在        | 文件间共享                   | 无          | 声明外部全局变量或函数     |
| `register`| 寄存器（如果可能）| 局部，函数结束时销毁        | 函数或代码块内               | 未初始化    | 提示存储在寄存器，提高访问速度 |