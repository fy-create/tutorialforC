---
layout: post
title:  "队列（Queue）"
categories: dataStruct
---

### 队列（Queue）的概念和应用

#### 概念
**队列（Queue）** 是一种 **FIFO**（First In, First Out，先进先出）结构，意味着最先进入队列的元素最先被处理。队列类似于排队等待的场景：第一个进入队列的人会第一个被服务。

#### 队列的常用操作
1. **enqueue**：将元素插入队列的尾部（入队）。
2. **dequeue**：移除并返回队列的头部元素（出队）。
3. **peek**：查看队列的头部元素，但不移除它。
4. **isEmpty**：检查队列是否为空。

#### 复杂度分析
- **enqueue**、**dequeue**、**peek** 和 **isEmpty** 操作的时间复杂度均为 **O(1)**，因为这些操作只涉及到对队列头尾指针的修改。

#### 队列的类型
1. **普通队列**：标准的 FIFO 队列，元素只能从尾部入队，从头部出队。
2. **双端队列（Deque）**：双端队列允许从两端进行入队和出队操作。
3. **优先队列**：优先队列中的元素根据优先级进行排序，优先级最高的元素最先出队。

#### 队列的应用
1. **BFS（广度优先搜索）**：在图遍历和树遍历算法中，广度优先搜索使用队列来实现。
2. **任务调度**：常用于操作系统、网络通信中的任务调度模型。

---

### 队列的实现

队列可以使用 **数组** 或 **链表** 来实现。数组实现需要注意队列的容量管理，链表实现更加灵活。

---

### 1. **基于数组的普通队列实现（C语言）**

#### 代码实现：
```c
#include <stdio.h>
#include <stdlib.h>

#define MAX 1000 // 队列的最大容量

// 使用 typedef 定义队列结构
typedef struct {
    int front, rear, size;
    int array[MAX];
} Queue;

// 创建并初始化队列
Queue* createQueue() {
    Queue* queue = (Queue*)malloc(sizeof(Queue));
    queue->front = 0;
    queue->size = 0;
    queue->rear = MAX - 1; // 初始化 rear 为数组的最后一位
    return queue;
}

// 检查队列是否为空
int isEmpty(Queue* queue) {
    return queue->size == 0;
}

// 检查队列是否已满
int isFull(Queue* queue) {
    return queue->size == MAX;
}

// enqueue 操作：将元素加入队列尾部
void enqueue(Queue* queue, int value) {
    if (isFull(queue)) {
        printf("Queue is full\n");
        return;
    }
    queue->rear = (queue->rear + 1) % MAX; // 循环利用数组空间
    queue->array[queue->rear] = value;
    queue->size++;
    printf("Enqueued %d\n", value);
}

// dequeue 操作：从队列头部移除元素
int dequeue(Queue* queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty\n");
        return -1;
    }
    int value = queue->array[queue->front];
    queue->front = (queue->front + 1) % MAX; // 循环利用数组空间
    queue->size--;
    return value;
}

// peek 操作：查看队列头部元素
int peek(Queue* queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty\n");
        return -1;
    }
    return queue->array[queue->front];
}

int main() {
    Queue* queue = createQueue();

    enqueue(queue, 10);
    enqueue(queue, 20);
    enqueue(queue, 30);

    printf("Front element is %d\n", peek(queue));

    printf("Dequeued %d\n", dequeue(queue));
    printf("Dequeued %d\n", dequeue(queue));

    if (isEmpty(queue)) {
        printf("Queue is empty\n");
    } else {
        printf("Queue is not empty\n");
    }

    return 0;
}
```

#### 输出：
```
Enqueued 10
Enqueued 20
Enqueued 30
Front element is 10
Dequeued 10
Dequeued 20
Queue is not empty
```

---

### 2. **基于链表的普通队列实现（C语言）**

链表实现的队列没有固定容量，动态分配内存，因此能够适应任意大小的队列需求。

#### 代码实现：
```c
#include <stdio.h>
#include <stdlib.h>

// 定义链表节点结构
typedef struct QueueNode {
    int data;
    struct QueueNode* next;
} QueueNode;

// 定义队列结构
typedef struct {
    QueueNode* front;
    QueueNode* rear;
} Queue;

// 创建新节点
QueueNode* createNode(int value) {
    QueueNode* newNode = (QueueNode*)malloc(sizeof(QueueNode));
    newNode->data = value;
    newNode->next = NULL;
    return newNode;
}

// 创建并初始化队列
Queue* createQueue() {
    Queue* queue = (Queue*)malloc(sizeof(Queue));
    queue->front = queue->rear = NULL;
    return queue;
}

// 检查队列是否为空
int isEmpty(Queue* queue) {
    return queue->front == NULL;
}

// enqueue 操作：将元素加入队列尾部
void enqueue(Queue* queue, int value) {
    QueueNode* newNode = createNode(value);
    if (queue->rear == NULL) {
        queue->front = queue->rear = newNode;
        printf("Enqueued %d\n", value);
        return;
    }
    queue->rear->next = newNode;
    queue->rear = newNode;
    printf("Enqueued %d\n", value);
}

// dequeue 操作：从队列头部移除元素
int dequeue(Queue* queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty\n");
        return -1;
    }
    QueueNode* temp = queue->front;
    int value = temp->data;
    queue->front = queue->front->next;

    if (queue->front == NULL) {
        queue->rear = NULL;
    }

    free(temp);
    return value;
}

// peek 操作：查看队列头部元素
int peek(Queue* queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty\n");
        return -1;
    }
    return queue->front->data;
}

int main() {
    Queue* queue = createQueue();

    enqueue(queue, 10);
    enqueue(queue, 20);
    enqueue(queue, 30);

    printf("Front element is %d\n", peek(queue));

    printf("Dequeued %d\n", dequeue(queue));
    printf("Dequeued %d\n", dequeue(queue));

    if (isEmpty(queue)) {
        printf("Queue is empty\n");
    } else {
        printf("Queue is not empty\n");
    }

    return 0;
}
```

#### 输出：
```
Enqueued 10
Enqueued 20
Enqueued 30
Front element is 10
Dequeued 10
Dequeued 20
Queue is not empty
```

---

### 3. **双端队列（Deque）的实现**

双端队列允许在队列的两端进行插入和删除操作。

#### 代码实现（基于数组）：
```c
#include <stdio.h>
#include <stdlib.h>

#define MAX 1000

typedef struct {
    int front, rear, size;
    int array[MAX];
} Deque;

// 初始化双端队列
Deque* createDeque() {
    Deque* deque = (Deque*)malloc(sizeof(Deque));
    deque->front = -1;
    deque->rear = 0;
    deque->size = 0;
    return deque;
}

// 检查双端队列是否为空
int isEmpty(Deque* deque) {
    return deque->size == 0;
}

// 检查双端队列是否已满
int isFull(Deque* deque) {
    return deque->size == MAX;
}

// 从前端插入元素
void insertFront(Deque* deque, int value) {
    if (isFull(deque)) {
        printf("Deque is full\n");
        return;
    }
    if (deque->front == -1) {
        deque->front = 0;
        deque->rear = 0;
    } else if (deque->front == 0) {
        deque->front = MAX - 1;
    } else {
        deque->front--;
    }
    deque->array[deque->front] = value;
    deque->size++;
    printf("Inserted %d at front\n", value);
}

// 从后端插入元素
void insertRear(Deque* deque, int value) {
    if (isFull(deque)) {
        printf("Deque is full\n");
        return;
    }
    if (deque->front == -1) {
        deque->front = 0;
        deque->rear = 0;
    } else if (deque->rear

 == MAX - 1) {
        deque->rear = 0;
    } else {
        deque->rear++;
    }
    deque->array[deque->rear] = value;
    deque->size++;
    printf("Inserted %d at rear\n", value);
}

// 从前端删除元素
int deleteFront(Deque* deque) {
    if (isEmpty(deque)) {
        printf("Deque is empty\n");
        return -1;
    }
    int value = deque->array[deque->front];
    if (deque->front == deque->rear) {
        deque->front = -1;
        deque->rear = -1;
    } else if (deque->front == MAX - 1) {
        deque->front = 0;
    } else {
        deque->front++;
    }
    deque->size--;
    return value;
}

// 从后端删除元素
int deleteRear(Deque* deque) {
    if (isEmpty(deque)) {
        printf("Deque is empty\n");
        return -1;
    }
    int value = deque->array[deque->rear];
    if (deque->front == deque->rear) {
        deque->front = -1;
        deque->rear = -1;
    } else if (deque->rear == 0) {
        deque->rear = MAX - 1;
    } else {
        deque->rear--;
    }
    deque->size--;
    return value;
}

// 获取前端元素
int getFront(Deque* deque) {
    if (isEmpty(deque)) {
        printf("Deque is empty\n");
        return -1;
    }
    return deque->array[deque->front];
}

// 获取后端元素
int getRear(Deque* deque) {
    if (isEmpty(deque)) {
        printf("Deque is empty\n");
        return -1;
    }
    return deque->array[deque->rear];
}

int main() {
    Deque* deque = createDeque();

    insertRear(deque, 10);
    insertFront(deque, 20);
    insertRear(deque, 30);

    printf("Front element is %d\n", getFront(deque));
    printf("Rear element is %d\n", getRear(deque));

    printf("Deleted front %d\n", deleteFront(deque));
    printf("Deleted rear %d\n", deleteRear(deque));

    return 0;
}
```

#### 输出：
```
Inserted 10 at rear
Inserted 20 at front
Inserted 30 at rear
Front element is 20
Rear element is 30
Deleted front 20
Deleted rear 30
```

---

### 4. **优先队列（Priority Queue）的概念**

优先队列中，元素按照优先级排序，优先级最高的元素最先出队。优先队列常用 **堆**（heap）实现，操作的时间复杂度为 **O(log n)**，因为需要维护堆结构的性质。

---

### 总结

- **队列** 是一种 **FIFO（先进先出）** 的数据结构，常用于 **BFS（广度优先搜索）**、**任务调度** 等场景。
- **双端队列（Deque）** 可以在两端进行插入和删除操作。
- **优先队列** 用于根据优先级处理任务。

队列的基本操作，如 **enqueue**、**dequeue**、**peek** 和 **isEmpty**，时间复杂度为 **O(1)**，因此非常高效。