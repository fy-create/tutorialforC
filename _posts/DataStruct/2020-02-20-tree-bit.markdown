---
layout: post
title:  "树状数据库（Fenwick Tree / Binary Indexed Tree, BIT）"
categories: dataStruct
---

### 树状数组（Fenwick Tree / Binary Indexed Tree, BIT）的概念和应用

#### 概念
**树状数组（Fenwick Tree 或 Binary Indexed Tree，简称 BIT）** 是一种高效解决 **前缀和问题** 的数据结构。它可以在 **O(log n)** 的时间内完成 **前缀和查询** 和 **单点更新** 操作。与线段树类似，树状数组能够高效处理区间查询问题，但实现相对简单，占用内存较小。

#### 树状数组的常见操作
1. **查询前缀和（Query Prefix Sum）**：查询数组中从第一个元素到某个指定位置的前缀和。
2. **单点更新（Point Update）**：更新数组中的某个元素，并维护树状数组的正确性。
3. **区间和查询（Range Query）**：通过两个前缀和查询实现某个区间的和，通常用 `sum(R) - sum(L-1)` 的方式。
4. **区间更新**：通过树状数组的技巧，可以实现区间更新问题。

#### 应用
- **前缀和查询**：查询一个数组的前缀和（如统计从数组开头到某个位置的元素总和）。
- **区间更新与查询**：通过一些变形，可以实现区间更新和区间查询操作。
- **逆序对计数**：在求解数组的逆序对问题中，树状数组可以高效地维护插入和计数。

---

### 树状数组的基本原理

树状数组通过一个额外的数组 `BIT[]` 来存储和维护数据的前缀和。对于树状数组中的每个元素 `BIT[i]`，它维护了某个区间的和，并且这个区间的大小由 **最低有效位（Lowest Set Bit, LSB）** 决定。通过增减最低有效位，我们能够高效地进行查询和更新。

#### 计算最低有效位
- **最低有效位（LSB）** 是指一个数的二进制表示中最右边的 `1` 所对应的位置。
- **计算公式**：`i & (-i)`，其中 `-i` 是 `i` 的补码（即取反加 1）。例如， `LSB(6)` 的结果为 `2`，因为 `6` 的二进制为 `110`，最低有效位是 `10` 对应的 2。

---

### 1. **树状数组的实现（C语言）**

#### 基本操作：前缀和查询与单点更新

#### 代码实现：

```c
#include <stdio.h>
#include <stdlib.h>

// 创建并初始化树状数组（长度为 n 的数组）
int* createBIT(int n) {
    int* BIT = (int*)malloc((n + 1) * sizeof(int)); // BIT 索引从 1 开始，因此分配 n+1 的大小
    for (int i = 0; i <= n; i++) {
        BIT[i] = 0;  // 初始化为 0
    }
    return BIT;
}

// 单点更新：将数组中索引 idx 的元素增加 value
void updateBIT(int* BIT, int n, int idx, int value) {
    idx++;  // BIT 的索引从 1 开始，因此需要将原索引加 1
    while (idx <= n) {
        BIT[idx] += value;  // 更新当前索引位置的值
        idx += idx & (-idx);  // 跳到下一个与 idx 有关的区间
    }
}

// 查询前缀和：返回数组中从 0 到 idx 的前缀和
int queryBIT(int* BIT, int idx) {
    idx++;  // BIT 的索引从 1 开始
    int sum = 0;
    while (idx > 0) {
        sum += BIT[idx];  // 累加前缀和
        idx -= idx & (-idx);  // 跳到上一个区间
    }
    return sum;
}

// 区间查询：查询数组中 [left, right] 的区间和
int rangeQueryBIT(int* BIT, int left, int right) {
    return queryBIT(BIT, right) - queryBIT(BIT, left - 1); // 通过两个前缀和计算区间和
}

int main() {
    // 初始化一个数组
    int arr[] = {1, 7, 3, 0, 5, 8, 3, 2, 6, 4};
    int n = sizeof(arr) / sizeof(arr[0]);

    // 创建树状数组
    int* BIT = createBIT(n);

    // 将原数组值更新到树状数组中
    for (int i = 0; i < n; i++) {
        updateBIT(BIT, n, i, arr[i]);
    }

    // 查询前缀和（从索引 0 到 4 的和）
    printf("Sum of elements from index 0 to 4: %d\n", queryBIT(BIT, 4));

    // 查询区间和（从索引 3 到 8 的和）
    printf("Sum of elements from index 3 to 8: %d\n", rangeQueryBIT(BIT, 3, 8));

    // 更新数组中的某个值（将索引 5 的值增加 5）
    updateBIT(BIT, n, 5, 5);

    // 再次查询前缀和和区间和
    printf("Sum of elements from index 0 to 4 after update: %d\n", queryBIT(BIT, 4));
    printf("Sum of elements from index 3 to 8 after update: %d\n", rangeQueryBIT(BIT, 3, 8));

    free(BIT);  // 释放内存
    return 0;
}
```

#### 输出：
```
Sum of elements from index 0 to 4: 16
Sum of elements from index 3 to 8: 24
Sum of elements from index 0 to 4 after update: 16
Sum of elements from index 3 to 8 after update: 29
```

#### 代码解释：
1. **创建树状数组**：使用 `createBIT` 函数初始化树状数组，大小为 `n + 1`，其中索引从 `1` 开始。
2. **单点更新**：使用 `updateBIT` 函数来更新树状数组。对于数组中的每次更新，我们会影响相关区间的和，这通过增加最低有效位来实现。
3. **前缀和查询**：使用 `queryBIT` 函数从 0 到 `idx` 索引计算前缀和，通过递减最低有效位来逐步累计前缀和。
4. **区间查询**：使用 `rangeQueryBIT` 函数通过两个前缀和的差计算出某个区间的和。
5. **单点更新后的查询**：更新后再次查询，显示更新生效。

---

### 2. **树状数组的时间复杂度分析**

1. **单点更新（Update）**：O(log n)
   - 每次更新操作涉及到树状数组中的若干节点，节点数量与数组大小 `n` 的对数成正比。通过递增最低有效位来遍历相关区间，因此单点更新的时间复杂度为 **O(log n)**。

2. **前缀和查询（Query）**：O(log n)
   - 查询操作也与 `n` 的对数成正比，逐步累加相应区间的和。通过递减最低有效位遍历相关区间，前缀和查询的时间复杂度为 **O(log n)**。

3. **区间查询（Range Query）**：O(log n)
   - 区间查询通过两个前缀和的差实现，因此时间复杂度也是 **O(log n)**。

---

### 3. **树状数组的应用场景**

#### 1. **前缀和问题**
树状数组可以高效解决 **前缀和** 问题，如快速计算从数组的起点到某个索引之间的所有元素的总和。这在许多算法和应用中是常见需求。

#### 2. **区间更新和查询**
通过使用树状数组的扩展，我们可以高效处理区间更新和查询问题。在某些情形下，我们甚至可以通过两棵树状数组来同时处理区间更新和区间查询。

#### 3. **逆序对计数**
在处理 **逆序对问题**（如数组的排序逆序对）时，树状数组可以帮助我们快速维护元素的插入顺序和查询某个范围内的元素个数，进而有效统计逆序对。

---

### 4. **树状数组的扩展：区间更新与区间查询**

通过扩展树状数组的基础操作，我们可以处理 **区间更新和区间查询** 的问题。通常的方法是使用 **两棵树状数组**：
1. 第一棵树 `BIT1[]` 处理

每个位置的增量更新。
2. 第二棵树 `BIT2[]` 处理区间的总和变化。
   
这种方式允许我们在 **O(log n)** 时间内实现区间加法更新，并查询任何区间的总和。

---

### 总结

- **树状数组（Fenwick Tree / Binary Indexed Tree, BIT）** 是一种高效的动态数据结构，支持在 **O(log n)** 时间内进行 **前缀和查询** 和 **单点更新** 操作。
- 主要应用于 **前缀和**、**区间查询**、**区间更新** 以及 **逆序对计数** 等场景。
- 树状数组的实现相对简单，并且通过扩展可以处理复杂的区间操作问题，是一种广泛应用于竞赛编程、数据分析等领域的强大工具。