---
layout: post
title:  "点亮LED深入解释(结合参考手册)"
categories: embed1
---


# STM32 初学者指南：详细解析 GPIO 控制 LED 闪烁的代码

## 目录

1. [背景知识](#背景知识)
   - [1.1 STM32 微控制器简介](#11-stm32-微控制器简介)
   - [1.2 内存映射与寄存器](#12-内存映射与寄存器)
   - [1.3 RCC（复位和时钟控制）](#13-rcc复位和时钟控制)
   - [1.4 GPIO（通用输入输出端口）](#14-gpio通用输入输出端口)
2. [代码详解](#代码详解)
   - [2.1 头文件和宏定义](#21-头文件和宏定义)
   - [2.2 寄存器结构体定义](#22-寄存器结构体定义)
   - [2.3 延迟函数 `delay()`](#23-延迟函数-delay)
   - [2.4 主函数 `main()`](#24-主函数-main)
3. [内存布局与偏移量详解](#内存布局与偏移量详解)
   - [3.1 外设基地址和总线基地址](#31-外设基地址和总线基地址)
   - [3.2 RCC 和 GPIOC 基地址计算](#32-rcc-和-gpioc-基地址计算)
   - [3.3 寄存器偏移量和位定义](#33-寄存器偏移量和位定义)
4. [参考手册中的寄存器取值范围](#参考手册中的寄存器取值范围)
   - [4.1 RCC->APB2ENR 寄存器](#41-rcc-apb2enr-寄存器)
   - [4.2 GPIOC->CRH 寄存器](#42-gpioc-crh-寄存器)
   - [4.3 GPIOC->BSRR 寄存器](#43-gpioc-bsrr-寄存器)
5. [二进制赋值解释](#二进制赋值解释)
   - [5.1 使能 GPIOC 时钟](#51-使能-gpioc-时钟)
   - [5.2 配置 GPIOC 13 引脚为输出模式](#52-配置-gpioc-13-引脚为输出模式)
6. [总结](#总结)
7. [硬件手册](#硬件手册相关)


---

## 背景知识

### 1.1 STM32 微控制器简介

STM32 是意法半导体（STMicroelectronics）推出的一系列基于 ARM Cortex-M 内核的微控制器，广泛应用于嵌入式系统开发。它们具有以下特点：

- **高性能**：基于 ARM Cortex-M 内核，提供强大的处理能力。
- **低功耗**：适用于对功耗有严格要求的应用场景。
- **丰富的外设接口**：包括 GPIO、ADC、USART、SPI、I2C 等，方便与各种外部设备连接。

### 1.2 内存映射与寄存器

在 STM32 微控制器中，**外设寄存器**通过**内存映射**的方式映射到微控制器的地址空间。这意味着我们可以通过访问特定的内存地址来读写寄存器，从而控制和配置外设的行为。

**打个比方**，可以将寄存器想象成微控制器内的“开关”和“按钮”，通过操作这些“开关”和“按钮”，我们可以控制微控制器的各个部分。而这些“开关”和“按钮”都被排列在特定的“地址”上，我们通过“地址”找到它们。

### 1.3 RCC（复位和时钟控制）

**RCC（Reset and Clock Control）** 模块用于管理微控制器的时钟和复位功能。

- **时钟配置**：设置系统时钟源和频率。
- **时钟使能**：为各个外设提供时钟信号。**未使能时钟的外设将无法工作**，就像没有电源一样。
- **复位控制**：控制外设的复位状态。

### 1.4 GPIO（通用输入输出端口）

**GPIO（General-Purpose Input/Output）** 是微控制器与外部设备交互的基本接口。

- **输入模式**：用于读取外部信号，如按键状态。
- **输出模式**：用于控制外部设备，如点亮或熄灭 LED。

---

## 代码详解

下面是需要解释的完整代码：  
这是我们在keil中编写的最原始的代码，利用了大量的库函数定义的`宏`

```c
void delay(volatile uint32_t count) {
    while (count--) {
        __asm("nop");  // 空操作，延时用
    }
}

int main(void) {
    // 1. 启用 GPIOC 时钟
    RCC->APB2ENR |= RCC_APB2ENR_IOPCEN;  // 设置 IOPCEN 位，启用 GPIOC 时钟

    // 2. 配置 PC13 为推挽输出模式
    GPIOC->CRH &= ~(GPIO_CRH_CNF13);     // 清除 CNF13 位（模式配置位）
    GPIOC->CRH |= GPIO_CRH_MODE13_1;     // 设置 MODE13 为 0b10（输出模式，2 MHz）

    while (1) {
        // 3. 点亮 LED（将 PC13 置为低电平）
        GPIOC->BSRR = GPIO_BSRR_BR13;    // 设置 BR13 位，将 PC13 置为低电平
        delay(500000);                   // 延时

        // 4. 熄灭 LED（将 PC13 置为高电平）
        GPIOC->BSRR = GPIO_BSRR_BS13;    // 设置 BS13 位，将 PC13 置为高电平
        delay(500000);                   // 延时
    }
}
```
**嵌入式代码,特别是库函数的方式,写起来短小精悍,一般的开发人员可能都不能完全理解，只能是强行的记忆下来，其实这些代码是很精妙的，背后的逻辑非常清楚。
库函数提供的`宏`和`结构体`充分的展现了C语言的强大优势，对硬件的操作非常的丝滑，这就是一个经典的例子,下面好好费分析他,搞懂之后对C语言的提高也有很大的帮助.**   

**经过编译器预处理之后的代码如下，所有的宏展开了，这里把相关的宏的定义和关键的结构体放到了注释中，方便查看。**

```c
#include <stdint.h>

/*************************** START************************
这些定义来源于stm32 的库函数头文件

// 定义外设基地址
#define PERIPH_BASE           ((uint32_t)0x40000000)

// AHB 总线外设基地址
#define AHBPERIPH_BASE        (PERIPH_BASE + 0x20000)

// RCC 基地址
#define RCC_BASE              (AHBPERIPH_BASE + 0x1000)
#define RCC                   ((RCC_TypeDef *) RCC_BASE)

// RCC 寄存器中的 GPIOC 时钟使能位
#define RCC_APB2ENR_IOPCEN    ((uint32_t)0x00000010)  // I/O port C clock enable

// APB2 总线外设基地址
#define APB2PERIPH_BASE       (PERIPH_BASE + 0x10000)

// GPIOC 基地址
#define GPIOC_BASE            (APB2PERIPH_BASE + 0x1000)
#define GPIOC                 ((GPIO_TypeDef *) GPIOC_BASE)

// GPIOC 寄存器中的引脚配置位
#define GPIO_CRH_CNF13        ((uint32_t)0x00C00000)  // CNF13[1:0] bits
#define GPIO_CRH_MODE13_1     ((uint32_t)0x00200000)  // MODE13[1]

// 定义 RCC 寄存器结构体
typedef struct
{
    volatile uint32_t CR;         // 偏移量：0x00
    volatile uint32_t CFGR;       // 偏移量：0x04
    volatile uint32_t CIR;        // 偏移量：0x08
    volatile uint32_t APB2RSTR;   // 偏移量：0x0C
    volatile uint32_t APB1RSTR;   // 偏移量：0x10
    volatile uint32_t AHBENR;     // 偏移量：0x14
    volatile uint32_t APB2ENR;    // 偏移量：0x18
    volatile uint32_t APB1ENR;    // 偏移量：0x1C
    volatile uint32_t BDCR;       // 偏移量：0x20
    volatile uint32_t CSR;        // 偏移量：0x24
} RCC_TypeDef;

// 定义 GPIO 寄存器结构体
typedef struct
{
    volatile uint32_t CRL;    // 偏移量：0x00
    volatile uint32_t CRH;    // 偏移量：0x04
    volatile uint32_t IDR;    // 偏移量：0x08
    volatile uint32_t ODR;    // 偏移量：0x0C
    volatile uint32_t BSRR;   // 偏移量：0x10
    volatile uint32_t BRR;    // 偏移量：0x14
    volatile uint32_t LCKR;   // 偏移量：0x18
} GPIO_TypeDef;
********************** END **************************************/


void delay(volatile uint32_t count)
{
    while (count--) {
        __asm("nop");
    }
}

int main(void)
{
    // 使能 GPIOC 时钟
    ((RCC_TypeDef *) ((0x40000000 + 0x20000) + 0x1000))->APB2ENR |= 0x00000010;

    // 配置 GPIOC 13 号引脚为推挽输出模式，最大速度 2 MHz
    ((GPIO_TypeDef *) ((0x40000000 + 0x10000) + 0x1000))->CRH &= ~0x00C00000;
    ((GPIO_TypeDef *) ((0x40000000 + 0x10000) + 0x1000))->CRH |= 0x00200000;

    int delay_time = 1000000 * 2;

    while (1) {
        // 熄灭 LED（复位引脚）
        ((GPIO_TypeDef *) ((0x40000000 + 0x10000) + 0x1000))->BSRR = 0x20000000;
        delay(delay_time);

        // 点亮 LED（置位引脚）
        ((GPIO_TypeDef *) ((0x40000000 + 0x10000) + 0x1000))->BSRR = 0x00002000;
        delay(delay_time);
    }
}
```
**乍一看上面的代码，感觉都是数字，非常混乱，其实都是有用意的，不用怕。**

### 2.1 头文件和宏定义

```c
#include <stdint.h>
```

- **`<stdint.h>`**：标准整数类型头文件，定义了如 `uint32_t` 等类型，确保代码的可移植性。
```c
typedef unsigned int uint32_t; // 这是一个4个byte无符号整形的定义
```

宏定义部分：

```c
#define PERIPH_BASE           ((uint32_t)0x40000000)
#define AHBPERIPH_BASE        (PERIPH_BASE + 0x20000)
#define RCC_BASE              (AHBPERIPH_BASE + 0x1000)
#define RCC                   ((RCC_TypeDef *) RCC_BASE)
#define RCC_APB2ENR_IOPCEN    ((uint32_t)0x00000010)  // I/O port C clock enable

#define APB2PERIPH_BASE       (PERIPH_BASE + 0x10000)
#define GPIOC_BASE            (APB2PERIPH_BASE + 0x1000)
#define GPIOC                 ((GPIO_TypeDef *) GPIOC_BASE)
#define GPIO_CRH_CNF13        ((uint32_t)0x00C00000)  // CNF13[1:0] bits
#define GPIO_CRH_MODE13_1     ((uint32_t)0x00200000)  // MODE13[1]
```

**解释：**

- **`PERIPH_BASE`**：外设基地址，`0x40000000`。
- **`AHBPERIPH_BASE`**：AHB(Advanced High-performance Bus 高级高性能总线) 总线外设基地址，`0x40000000 + 0x20000 = 0x40020000`。
- **`RCC_BASE`**：RCC 寄存器基地址，`0x40020000 + 0x1000 = 0x40021000`。
- **`RCC`**：通过基地址类型转换，得到 RCC 寄存器的结构体指针。
- **`RCC_APB2ENR_IOPCEN`**：用于使能 GPIOC 时钟的位掩码，值为 `0x00000010`。  

- **`APB2PERIPH_BASE`**：APB2(Advanced Peripheral Bus 2 高级外设总线 2) 总线外设基地址，`0x40000000 + 0x10000 = 0x40010000`。
- **`GPIOC_BASE`**：GPIOC 寄存器基地址，`0x40010000 + 0x1000 = 0x40011000`。
- **`GPIOC`**：通过基地址类型转换，得到 GPIOC 寄存器的结构体指针。
- **`GPIO_CRH_CNF13`**：用于操作引脚 13 的 CNF13[1:0] 配置位，值为 `0x00C00000`。
- **`GPIO_CRH_MODE13_1`**：用于设置引脚 13 的 MODE13[1] 位，值为 `0x00200000`。

**打个比方**，这些宏定义就像是为我们准备好的“地图”，通过指定的“路标”（地址），我们可以准确地找到微控制器内的特定位置（寄存器）。

### 2.2 寄存器结构体定义

**RCC 寄存器结构体：**

```c
typedef struct
{
    volatile uint32_t CR;         // 偏移量：0x00（时钟控制寄存器）
    volatile uint32_t CFGR;       // 偏移量：0x04（时钟配置寄存器）
    volatile uint32_t CIR;        // 偏移量：0x08（时钟中断寄存器）
    volatile uint32_t APB2RSTR;   // 偏移量：0x0C（APB2 外设复位寄存器）
    volatile uint32_t APB1RSTR;   // 偏移量：0x10（APB1 外设复位寄存器）
    volatile uint32_t AHBENR;     // 偏移量：0x14（AHB 外设时钟使能寄存器）
    volatile uint32_t APB2ENR;    // 偏移量：0x18（APB2 外设时钟使能寄存器）
    volatile uint32_t APB1ENR;    // 偏移量：0x1C（APB1 外设时钟使能寄存器）
    volatile uint32_t BDCR;       // 偏移量：0x20（备份域控制寄存器）
    volatile uint32_t CSR;        // 偏移量：0x24（控制/状态寄存器）
} RCC_TypeDef;
```

**GPIO 寄存器结构体：**

```c
typedef struct
{
    volatile uint32_t CRL;    // 偏移量：0x00（端口配置寄存器低位，引脚 0-7）
    volatile uint32_t CRH;    // 偏移量：0x04（端口配置寄存器高位，引脚 8-15）
    volatile uint32_t IDR;    // 偏移量：0x08（输入数据寄存器）
    volatile uint32_t ODR;    // 偏移量：0x0C（输出数据寄存器）
    volatile uint32_t BSRR;   // 偏移量：0x10（位设置/复位寄存器）
    volatile uint32_t BRR;    // 偏移量：0x14（位复位寄存器）
    volatile uint32_t LCKR;   // 偏移量：0x18（端口配置锁定寄存器）
} GPIO_TypeDef;
```

**解释：**

- **`volatile`**：告诉编译器不要优化对这些寄存器的访问，因为它们的值可能会在程序未知的情况下发生改变。
- **偏移量**：每个寄存器在结构体中的位置，与基地址的距离。

**打个比方**，可以将结构体想象成一个大楼的楼层，每个寄存器是楼层中的房间，偏移量就是房间与大门（基地址）的距离。

### 2.3 延迟函数 `delay()`

```c
void delay(volatile uint32_t count)
{
    while (count--) {
        __asm("nop");
    }
}
```

**解释：**

- **功能**：实现一个简单的延迟函数，通过执行空操作来消耗时间。
- **`volatile`**：防止编译器优化 `count` 变量，确保延迟循环不会被省略。
- **`__asm("nop")`**：嵌入汇编指令 `NOP`，表示空操作，消耗一个 CPU 时钟周期。

**打个比方**，这个延迟函数就像是在等待，数着倒计时牌，一个一个地数，直到数完为止。

### 2.4 主函数 `main()`

```c
int main(void)
{
    // 使能 GPIOC 时钟
    ((RCC_TypeDef *) ((0x40000000 + 0x20000) + 0x1000))->APB2ENR |= 0x00000010;

    // 配置 GPIOC 13 号引脚为推挽输出模式，最大速度 2 MHz
    ((GPIO_TypeDef *) ((0x40000000 + 0x10000) + 0x1000))->CRH &= ~0x00C00000;
    ((GPIO_TypeDef *) ((0x40000000 + 0x10000) + 0x1000))->CRH |= 0x00200000;

    int delay_time = 1000000 * 2;

    while (1) {
        // 熄灭 LED（复位引脚）
        ((GPIO_TypeDef *) ((0x40000000 + 0x10000) + 0x1000))->BSRR = 0x20000000;
        delay(delay_time);

        // 点亮 LED（置位引脚）
        ((GPIO_TypeDef *) ((0x40000000 + 0x10000) + 0x1000))->BSRR = 0x00002000;
        delay(delay_time);
    }
}
```

---

## 内存布局与偏移量详解

### 3.1 外设基地址和总线基地址

- **外设基地址（`PERIPH_BASE`）**：`0x40000000`。

STM32 微控制器的外设分布在不同的总线上，包括 **AHB 总线** 和 **APB2 总线**。

- **AHB 外设基地址（`AHBPERIPH_BASE`）**：

  ```c
  AHBPERIPH_BASE = PERIPH_BASE + 0x20000 = 0x40000000 + 0x00020000 = 0x40020000;
  ```

- **APB2 外设基地址（`APB2PERIPH_BASE`）**：

  ```c
  APB2PERIPH_BASE = PERIPH_BASE + 0x10000 = 0x40000000 + 0x00010000 = 0x40010000;
  ```

**打个比方**，可以将 `PERIPH_BASE` 想象成一个城市的起点，从这里开始，通过不同的道路（总线），我们可以到达不同的区域（外设）。

### 3.2 RCC 和 GPIOC 基地址计算

#### 3.2.1 RCC 基地址计算

```c
RCC_BASE = AHBPERIPH_BASE + 0x1000 = (0x40000000 + 0x20000) + 0x1000 = 0x40021000;
```

- **步骤：**

  1. **`AHBPERIPH_BASE`**：`0x40000000 + 0x20000 = 0x40020000`。
  2. **加上偏移量 `0x1000`**：`0x40020000 + 0x1000 = 0x40021000`。

**在代码中：**

```c
((RCC_TypeDef *) ((0x40000000 + 0x20000) + 0x1000))
```

- **解释**：通过累加的方式计算出 RCC 的基地址，然后将其转换为 `RCC_TypeDef` 类型的指针，方便访问 RCC 寄存器。

#### 3.2.2 GPIOC 基地址计算

```c
GPIOC_BASE = APB2PERIPH_BASE + 0x1000 = (0x40000000 + 0x10000) + 0x1000 = 0x40011000;
```

- **步骤：**

  1. **`APB2PERIPH_BASE`**：`0x40000000 + 0x10000 = 0x40010000`。
  2. **加上偏移量 `0x1000`**：`0x40010000 + 0x1000 = 0x40011000`。

**在代码中：**

```c
((GPIO_TypeDef *) ((0x40000000 + 0x10000) + 0x1000))
```

- **解释**：通过累加计算出 GPIOC 的基地址，然后转换为 `GPIO_TypeDef` 类型的指针。

### 3.3 寄存器偏移量和位定义

#### 3.3.1 RCC 寄存器

- **`APB2ENR`**（APB2 外设时钟使能寄存器）：

  - **偏移量**：`0x18`（在 `RCC_TypeDef` 中的第 7 个成员）。
  - **地址**：`RCC_BASE + 0x18 = 0x40021000 + 0x18 = 0x40021018`。

- **`RCC_APB2ENR_IOPCEN`**：

  - **值**：`0x00000010`。
  - **含义**：`APB2ENR` 寄存器的第 4 位（位 4），用于使能 GPIOC 时钟。

#### 3.3.2 GPIOC 寄存器

- **`CRH`**（端口配置寄存器高位）：

  - **偏移量**：`0x04`（在 `GPIO_TypeDef` 中的第 2 个成员）。
  - **地址**：`GPIOC_BASE + 0x04 = 0x40011000 + 0x04 = 0x40011004`。

- **`BSRR`**（位设置/复位寄存器）：

  - **偏移量**：`0x10`（在 `GPIO_TypeDef` 中的第 5 个成员）。
  - **地址**：`GPIOC_BASE + 0x10 = 0x40011000 + 0x10 = 0x40011010`。

#### 3.3.3 引脚 13 的配置位

- **在 `CRH` 寄存器中**：

  - **引脚 13（Pin 13）**对应位 [23:20]。
  - **`GPIO_CRH_CNF13`**：`0x00C00000`，用于操作 CNF13[1:0] 配置位（位 23:22）。
  - **`GPIO_CRH_MODE13_1`**：`0x00200000`，用于设置 MODE13[1] 位（位 21）。

---

## 参考手册中的寄存器取值范围

### 4.1 RCC->APB2ENR 寄存器

**APB2 外设时钟使能寄存器（APB2ENR）**

| 位段  | 名称     | 描述                       |
|-------|----------|----------------------------|
| 位 4  | IOPCEN   | I/O 端口 C 时钟使能        |
| 位 2  | IOPAEN   | I/O 端口 A 时钟使能        |
| 位 3  | IOPBEN   | I/O 端口 B 时钟使能        |
| 位 5  | IOPDEN   | I/O 端口 D 时钟使能        |
| ...   | ...      | ...                        |

- **值为 1**：使能对应外设的时钟。
- **值为 0**：关闭对应外设的时钟。

### 4.2 GPIOC->CRH 寄存器

**端口配置寄存器高位（CRH）**

对于每个引脚（8-15），有 4 位用于配置：

- **[CNFy1 CNFy0 MODEy1 MODEy0]**

引脚 13 的配置位在位 [23:20]。

| 位段             | 描述                             |
|------------------|----------------------------------|
| MODE13[1:0]      | 引脚 13 的输出模式和速度         |
| CNF13[1:0]       | 引脚 13 的配置（推挽、开漏等）   |

**MODE13[1:0] 配置**

| MODE13[1:0] | 模式                  |
|-------------|-----------------------|
| 00          | 输入模式              |
| 01          | 输出模式，速度 10 MHz |
| 10          | 输出模式，速度 2 MHz  |
| 11          | 输出模式，速度 50 MHz |

**CNF13[1:0] 配置（输出模式下）**

| CNF13[1:0] | 模式             |
|------------|------------------|
| 00         | 通用推挽输出     |
| 01         | 通用开漏输出     |
| 10         | 复用功能推挽输出 |
| 11         | 复用功能开漏输出 |

### 4.3 GPIOC->BSRR 寄存器

**位设置/复位寄存器（BSRR）**

| 位段        | 描述                                  |
|-------------|---------------------------------------|
| BSy (0-15)  | 置位位，将对应引脚置为高电平（1）     |
| BRy (16-31) | 复位位，将对应引脚置为低电平（0）     |

- **写入 1**：执行对应的置位或复位操作。
- **写入 0**：无影响。

---

## 二进制赋值解释

### 5.1 使能 GPIOC 时钟

```c
((RCC_TypeDef *) ((0x40000000 + 0x20000) + 0x1000))->APB2ENR |= 0x00000010;
```

**解释：**

- **`0x00000010` 二进制表示**：`0b00000000000000000000000000010000`

- **操作**：将 `APB2ENR` 寄存器的位 4 置为 1。

- **结果**：使能 GPIOC 的时钟。

### 5.2 配置 GPIOC 13 引脚为输出模式

#### 5.2.1 清除 CNF13[1:0] 位

```c
((GPIO_TypeDef *) ((0x40000000 + 0x10000) + 0x1000))->CRH &= ~0x00C00000;
```

- **`0x00C00000` 二进制表示**：`0b00000000110000000000000000000000`

- **操作**：将 `CRH` 寄存器的位 [23:22] 清零。

- **结果**：清除引脚 13 的 CNF13[1:0] 配置位。

#### 5.2.2 设置 MODE13[1] 位

```c
((GPIO_TypeDef *) ((0x40000000 + 0x10000) + 0x1000))->CRH |= 0x00200000;
```

- **`0x00200000` 二进制表示**：`0b00000000001000000000000000000000`

- **操作**：将 `CRH` 寄存器的位 21 置为 1。

- **结果**：将引脚 13 的 MODE13[1:0] 设置为 `10`，即输出模式，速度 2 MHz。

---

## 总结

通过对代码的详细解析和内存布局的说明，我们了解了以下内容：

1. **使能 GPIOC 时钟**：通过 RCC 的 `APB2ENR` 寄存器，将位 4 置 1，使能 GPIOC 的时钟。

2. **配置 GPIOC 13 引脚为推挽输出模式**：通过 GPIOC 的 `CRH` 寄存器，清除 CNF13[1:0] 位，设置 MODE13[1] 位，将引脚 13 配置为输出模式，速度 2 MHz，推挽输出。

3. **控制 LED 的亮灭**：通过 GPIOC 的 `BSRR` 寄存器，置位或复位引脚 13，实现 LED 的亮灭。

4. **理解内存地址的计算**：通过累加的方式计算基地址和偏移量，有助于理解 STM32 的内存映射机制。

5. **使用二进制解释寄存器赋值**：通过将赋值的数值转换为二进制，更直观地了解哪些位被操作。

**打个比方**，整个过程就像是：

- **找到电源总开关**（使能 GPIOC 时钟）。
- **设置灯的工作模式**（配置 GPIO 引脚模式）。
- **开关灯的按钮**（置位或复位引脚电平）。
- **按照地址找到每个开关和按钮**（内存地址计算）。

---


**学习建议：**

- **深入阅读 STM32 参考手册**：了解更多关于寄存器、偏移量和位定义的信息，有助于掌握底层编程技巧。

- **实践操作**：在实际的 STM32 开发板上运行代码，观察 LED 的闪烁，增强理解。

- **修改代码**：尝试更改延迟时间、控制其他 GPIO 引脚，进一步熟悉 GPIO 的使用。

---

<BR><BR><BR>

## 硬件手册相关
STM32F10xxx参考手册（中文）.pdf

### 可以看到RCC相关寄存器的地址范围，跟我们程序中写的数据是吻合的。
```c
((RCC_TypeDef *) ((0x40000000 + 0x20000) + 0x1000))->APB2ENR |= 0x00000010;
```
<a href="{{ site.baseurl }}/assets/images/keil/manual_0.png" target="_blank">
  <img src="{{ site.baseurl }}/assets/images/keil/manual_0.png" alt="存储器映像">
</a>  



**RCC寄存器地址映像和复位值**
<a href="{{ site.baseurl }}/assets/images/keil/manual_1.png" target="_blank">
  <img src="{{ site.baseurl }}/assets/images/keil/manual_1.png" alt="RCC寄存器地址映像和复位值">
</a>

---
<BR>
### 可以看到GPIOC相关寄存器的地址范围，跟我们程序中写的数据是吻合的。  


```c
((GPIO_TypeDef *) ((0x40000000 + 0x10000) + 0x1000))->CRH &= ~0x00C00000;
((GPIO_TypeDef *) ((0x40000000 + 0x10000) + 0x1000))->CRH |= 0x00200000;
```

**GPIOC**
<a href="{{ site.baseurl }}/assets/images/keil/manual_2.png" target="_blank">
  <img src="{{ site.baseurl }}/assets/images/keil/manual_2.png" alt="GPIOC">
</a>

<a href="{{ site.baseurl }}/assets/images/keil/manual_3.png" target="_blank">
  <img src="{{ site.baseurl }}/assets/images/keil/manual_3.png" alt="GPIOC">
</a>

