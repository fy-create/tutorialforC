---
layout: post
title:  "启用GPIOC时钟C语言实例讲解"
categories: embed1
---


下面5段代码的核心任务都是通过修改 STM32 微控制器中的 **RCC->APB2ENR** 寄存器的特定位来启用 **GPIOC** 的时钟。我们将逐步分析每一段代码并结合内存布局详细解释它们的内存操作。  



### 1. 背景信息

- **`RCC->APB2ENR`** 寄存器：这是 **APB2 外设时钟使能寄存器**，其地址为 `0x40021018`。通过设置寄存器中的位，我们可以启用或禁用某个外设的时钟。
- **`RCC_APB2ENR_IOPCEN`**：这是一个宏，定义为 `0x00000010`，表示 **GPIOC 时钟使能位**，位于 `APB2ENR` 寄存器的第 4 位。
  

**其实我们的目标很明确，我们查手册知道 0x40021018 这个就是我们要操作的目标寄存器，他是一个32位的寄存器，可以假想有32个小格子，每个格子可以存放一个bit (0或1). 我们需要把第4个格子里面放入1 (从0开始数)。这种在某个地址放入某个东西的操作跟C语言的指针`*p = xxx`或者`p->member = xxx`操作太吻合了。所以我觉得C语言作为首选的硬件操作语言是非常合适的.**

我们假设 `APB2ENR` 寄存器的初始值为 `0x00000000`，表示 GPIOC 时钟未启用。
### 2. 内存布局

在解释代码前，先展示相关寄存器的内存布局。这里展示从 `0x40021000` 开始的 **RCC** 寄存器区域，重点是 **`APB2ENR`** 寄存器的内存地址 `0x40021018`。

```
地址         03 02 01 00  
-------------------------
0x40021000: 00 00 00 00   |  CR      |
0x40021004: 00 00 00 00   |  CFGR    |
0x40021008: 00 00 00 00   |  CIR     |
0x4002100C: 00 00 00 00   |  APB2RSTR|
0x40021010: 00 00 00 00   |  APB1RSTR|
0x40021014: 00 00 00 00   |  AHBENR  |
0x40021018: 00 00 00 00   |  APB2ENR |
0x4002101C: 00 00 00 00   |  APB1ENR |
0x40021020: 00 00 00 00   |  BDCR    |
```

| 地址           | 偏移量 | 内容       | 寄存器名称      | 描述                          |
|----------------|--------|------------|----------------|-------------------------------|
| **0x40021000** | `0x00` | 00 00 00 00 | `RCC->CR`      | 时钟控制寄存器                |
| **0x40021004** | `0x04` | 00 00 00 00 | `RCC->CFGR`    | 时钟配置寄存器                |
| **0x40021008** | `0x08` | 00 00 00 00 | `RCC->CIR`     | 时钟中断寄存器                |
| **0x4002100C** | `0x0C` | 00 00 00 00 | `RCC->APB2RSTR`| APB2 外设复位寄存器           |
| **0x40021010** | `0x10` | 00 00 00 00 | `RCC->APB1RSTR`| APB1 外设复位寄存器           |
| **0x40021014** | `0x14` | 00 00 00 00 | `RCC->AHBENR`  | AHB 外设时钟使能寄存器        |
| **0x40021018** | `0x18` | **00 00 00 00** | **`RCC->APB2ENR`** | **APB2 外设时钟使能寄存器**    |
| **0x4002101C** | `0x1C` | 00 00 00 00 | `RCC->APB1ENR` | APB1 外设时钟使能寄存器       |




#### 初始状态

假设 `APB2ENR` 寄存器的初始值为 `0x00000000`，即 GPIOC 的时钟没有启用。

### 3. 分析下面5段代码

#### 第一段代码
**这是使用库函数的方法，简单直接，可读性强。利用了大量的宏，但是也隐藏了实现的细节，一般人只能通过字面了解，完全不知道背后在干什么。**
```c
RCC->APB2ENR |= RCC_APB2ENR_IOPCEN;
```

##### 解释：

1. **`RCC->APB2ENR`**：这是直接通过 `RCC` 寄存器访问 `APB2ENR` 寄存器，`RCC_APB2ENR_IOPCEN` 是一个宏，值为 `0x00000010`。
2. **操作**：通过 `|=`（位或操作），将 `APB2ENR` 寄存器的第 4 位（对应 GPIOC 时钟使能位）设置为 1。  
`|=` 是C语言的一种`复合赋值运算符`，等同于
```c
RCC->APB2ENR = RCC->APB2ENR | RCC_APB2ENR_IOPCEN;
```
意思是，先把左边自己的数据拿出来，跟等号右边做 | 运算，然后再把运算后的结果写回到左边。也就是两部并一步。
类似的还有


```c
#include <stdio.h>

int main() {
    int a = 10;

    a += 2;    // a = a + 2;   结果：a = 12
    a -= 4;    // a = a - 4;   结果：a = 8
    a *= 3;    // a = a * 3;   结果：a = 24
    a /= 2;    // a = a / 2;   结果：a = 12
    a %= 5;    // a = a % 5;   结果：a = 2
    a &= 3;    // a = a & 3;   结果：a = 2
    a |= 1;    // a = a | 1;   结果：a = 3
    a ^= 1;    // a = a ^ 1;   结果：a = 2
    a <<= 2;   // a = a << 2;  结果：a = 8
    a >>= 1;   // a = a >> 1;  结果：a = 4

    printf("a 的最终值是：%d\n", a);  // 输出 a 的最终值
    return 0;
}
```


##### 结果：
经过 `RCC->APB2ENR |= RCC_APB2ENR_IOPCEN;` 之后
- 内存地址 `0x40021018` 的值从 `0x00000000` 修改为 `0x00000010`，GPIOC 时钟被启用。

---
<BR><BR>
#### 第二段代码
**这段代码其实就是上面第一段代码的宏展开**
```c
{
    ((RCC_TypeDef *) ((0x40000000 + 0x20000) + 0x1000))->APB2ENR |= 0x00000010;
}
```

##### 解释：

1. **地址计算**：`0x40000000 + 0x20000 + 0x1000` 最终计算出的地址是 `0x40021000`，这是 **RCC** 寄存器的基地址。
2. **强制类型转换**：将 `0x40021000` 转换为 `RCC_TypeDef *` 类型的指针，然后访问其 `APB2ENR` 寄存器。 `((RCC_TypeDef *) ((0x40000000 + 0x20000) + 0x1000))` 这种写法就可以理解为一个没有变量名字的指针，把他看成一个指针变量`p`,这个`p`的类型是`RCC_TypeDef *`。
3. **位或操作**：将 `0x00000010`（GPIOC 时钟使能位）设置为 1。

##### 结果：
- 这段代码的效果与第一段完全相同，内存地址 `0x40021018` 的值变为 `0x00000010`，GPIOC 时钟被启用。

---

#### 第三段代码

```c
{
    uint32_t* pt_APB2ENR = (uint32_t* ) 0x40021018;
    *pt_APB2ENR |= 0x00000010;
}
```

##### 解释：

1. **定义指针**：`pt_APB2ENR` 是一个指向 32 位（4 字节）的指针，指向内存地址 `0x40021018`。
2. **位或操作**：通过该指针直接访问 `APB2ENR` 寄存器，并将第 4 位设置为 1。

##### 结果：
- 与前两段代码相同，内存地址 `0x40021018` 的值被修改为 `0x00000010`，GPIOC 时钟被启用。

---

#### 第四段代码

```c
{
    *( (uint32_t*)0x40021018 ) |= 0x00000010;
}
```

##### 解释：

1. **强制类型转换并操作**：将地址 `0x40021018` 转换为 `uint32_t*` 类型的指针，并直接对该地址的值进行位或操作，设置 GPIOC 时钟使能位。
2. **直接操作**：没有显式定义指针变量，直接通过内存地址操作。

##### 结果：
- 与前三段代码相同，修改了 `APB2ENR` 寄存器的第 4 位，启用 GPIOC 时钟。

---

#### 第五段代码

```c
{
    uint8_t* pt_APB2ENR = (uint8_t* ) 0x40021018;
    *pt_APB2ENR |= 0x10;
}
```

##### 解释：

1. **定义指针**：`pt_APB2ENR` 是一个指向 8 位（1 字节）的指针，指向内存地址 `0x40021018`。
2. **位或操作**：这里通过 `uint8_t*` 只操作最低的 1 字节，设置第 4 位（GPIOC 时钟使能位）为 1。

##### 结果：
- 虽然只操作了 1 字节，但由于 GPIOC 的时钟使能位位于该字节，因此效果与前四段代码相同，启用了 GPIOC 时钟。

---

### 4. 内存变化分析

所有这 5 段代码，操作的都是 `APB2ENR` 寄存器的第 4 位，启用 GPIOC 时钟。无论通过哪种方式，最终都将 `APB2ENR` 的值从 `0x00000000` 修改为 `0x00000010`。

#### 修改前的内存状态

| 地址           | 内容       | 寄存器名称      | 描述                          |
|----------------|------------|----------------|-------------------------------|
| **0x40021018** | 00 00 00 00 | `APB2ENR`      | GPIOC 时钟未启用              |

#### 修改后的内存状态（5 段代码执行后的效果相同）

| 地址           | 内容       | 寄存器名称      | 描述                          |
|----------------|------------|----------------|-------------------------------|
| **0x40021018** | **00 00 00 10** | **`APB2ENR`**  | **GPIOC 时钟已启用**           |

### 5. 五段代码的差异

- **第一段和第二段代码**：分别使用直接访问和计算指针方式操作 `RCC->APB2ENR`，修改了 32 位寄存器。
- **第三段和第四段代码**：通过显式和隐式的 32 位指针操作内存地址，修改了 32 位寄存器。


- **第五段代码**：通过 8 位指针操作最低的 1 字节，虽然只操作 1 字节，但由于 GPIOC 时钟使能位在该字节中，因此结果与前几段代码相同。

### 总结

这 5 段代码通过不同的方式完成了相同的功能，即通过修改 STM32 微控制器 `RCC->APB2ENR` 寄存器的第 4 位，启用 GPIOC 的时钟。最终，它们都将 `APB2ENR` 寄存器的值从 `0x00000000` 修改为 `0x00000010`，从而启用了 GPIOC 外设的时钟。