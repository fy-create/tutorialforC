---
layout: post
title:  "LED相关-了解寄存器的相关概念"
categories: embed1
---

# **了解寄存器的相关概念，并根据手册或者源码找出与点亮LED灯相关的寄存器，并说明它们的作用**


在 **STM32F103C8T6** 中，直接通过操作寄存器来点亮板载 **LED**（通常连接在 **PC13** 引脚上）是一种常见的嵌入式开发方式。通过直接操作寄存器，你可以更高效地控制硬件。  

#### 以下是通过直接操作寄存器点亮 **PC13 引脚**上的板载 LED 的示例代码：

```c
#include "stm32f10x.h"

void delay(volatile uint32_t count) {
    while (count--) {
        __asm("nop");  // 空操作，延时用
    }
}

int main(void) {
    // 1. 启用 GPIOC 时钟
    RCC->APB2ENR |= RCC_APB2ENR_IOPCEN;  // 设置 IOPCEN 位，启用 GPIOC 时钟

    // 2. 配置 PC13 为推挽输出模式
    GPIOC->CRH &= ~(GPIO_CRH_CNF13);     // 清除 CNF13 位（模式配置位）
    GPIOC->CRH |= GPIO_CRH_MODE13_1;     // 设置 MODE13 为 0b10（输出模式，2 MHz）

    while (1) {
        // 3. 点亮 LED（将 PC13 置为低电平）
        GPIOC->BSRR = GPIO_BSRR_BR13;    // 设置 BR13 位，将 PC13 置为低电平
        delay(500000);                   // 延时

        // 4. 熄灭 LED（将 PC13 置为高电平）
        GPIOC->BSRR = GPIO_BSRR_BS13;    // 设置 BS13 位，将 PC13 置为高电平
        delay(500000);                   // 延时
    }
}
```

### **步骤 1：了解相关寄存器**

- **RCC_APB2ENR（外设时钟控制寄存器）**：
  - 使能 GPIOC 时钟，通过启用时钟来激活 GPIO 外设。
  - **RCC->APB2ENR** 寄存器的第 4 位（IOPCEN）控制 GPIOC 时钟。
  
- **GPIOC_CRH（GPIO 端口配置寄存器）**：
  - 配置 PC13 引脚的工作模式，如输入、输出、推挽输出等。
  - **GPIO_CRH** 控制 PC8-PC15 引脚的模式设置。

- **GPIOC_BSRR（GPIO 位设置/复位寄存器）**：
  - 设置或清除 PC13 引脚的状态，用于控制引脚电平。
  - **GPIO_BSRR** 可以将指定引脚置为高电平或低电平。

### **步骤 2：寄存器说明**

## RCC_APB2ENR 寄存器：
**`RCC_APB2ENR`** 是 **STM32F103** 微控制器中 **RCC（Reset and Clock Control，复位和时钟控制器）** 外设的一个寄存器，用于控制 **APB2 总线**上外设的时钟使能。通过设置或清除 **RCC_APB2ENR** 寄存器中的相应位，可以开启或关闭对应外设的时钟。只有在使能时钟后，相关外设才能正常工作。

### **`RCC_APB2ENR` 的作用**
- **APB2ENR** 全称是 **APB2 Peripheral Clock Enable Register**，即 **APB2 外设时钟使能寄存器**。
- **APB2 总线**用于连接部分高速外设，如 GPIO、USART1、ADC1、ADC2、TIM1、SPI1 等。
- 如果未启用时钟，APB2 总线上的外设将无法工作。
- **APB2** 是 **Advanced Peripheral Bus 2**（高级外设总线 2）的缩写，是 STM32 微控制器中的一个外设总线，用于连接较高速的外设。APB2 主要用于连接需要更高带宽的外设设备，如 GPIO、USART1、SPI1、ADC1、ADC2、TIM1 等

### **`RCC_APB2ENR` 寄存器结构**
`RCC_APB2ENR` 是一个 32 位的寄存器，每一位对应一个外设的时钟控制。设置某个位为 `1` 使能相应外设的时钟，设置为 `0` 则关闭该外设的时钟。

#### **`RCC_APB2ENR` 各位的定义**

| 位   | 名称        | 描述                                      |
|------|-------------|-------------------------------------------|
| 0    | AFIOEN      | 使能 **AFIO** 时钟（复用功能 I/O 时钟）   |
| 2    | IOPAEN      | 使能 **GPIOA** 时钟                       |
| 3    | IOPBEN      | 使能 **GPIOB** 时钟                       |
| 4    | IOPCEN      | 使能 **GPIOC** 时钟                       |
| 5    | IOPDEN      | 使能 **GPIOD** 时钟                       |
| 6    | IOPEEN      | 使能 **GPIOE** 时钟                       |
| 9    | ADC1EN      | 使能 **ADC1** 时钟                        |
| 10   | ADC2EN      | 使能 **ADC2** 时钟                        |
| 11   | TIM1EN      | 使能 **TIM1** 时钟                        |
| 12   | SPI1EN      | 使能 **SPI1** 时钟                        |
| 14   | USART1EN    | 使能 **USART1** 时钟                      |
| 17   | TIM8EN      | 使能 **TIM8** 时钟                        |

其他位对应的外设可以参考具体的 STM32F103 参考手册。

#### **重要位的解释**
- **IOPCEN（位 4）**：使能 **GPIOC** 端口的时钟。要使用 GPIOC 的引脚（如 PC13 控制板载 LED），必须先设置此位。
- **USART1EN（位 14）**：使能 **USART1** 时钟。要使用 USART1 进行串口通信，必须使能此位。
- **AFIOEN（位 0）**：使能 **AFIO** 时钟，**AFIO（Alternate Function I/O）** 提供外设引脚复用功能。

### **RCC_APB2ENR 的寄存器地址**

- **寄存器基地址**：`0x40021018`（`RCC_APB2ENR` 寄存器的地址）。
- 你可以通过这个地址直接访问寄存器的内容，进行时钟使能的操作。

### **如何在代码中使用 `RCC_APB2ENR`**

在使用 STM32 的标准外设库或直接操作寄存器时，我们需要操作 **`RCC_APB2ENR`** 来启用特定外设的时钟。

#### **标准库代码示例**
如果使用 **STM32 标准外设库**，你可以使用库函数来启用外设时钟。以启用 GPIOC 为例：

```c
// 使能 GPIOC 时钟
RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);
```

#### **直接操作寄存器代码示例**
如果你直接操作寄存器来启用 GPIOC 的时钟，可以这样写：

```c
// 使能 GPIOC 时钟
RCC->APB2ENR |= RCC_APB2ENR_IOPCEN;
```

#### **详细解释：**
- `RCC->APB2ENR` 是 RCC 外设的 **APB2ENR 寄存器**，用于控制 APB2 总线外设的时钟。
- `RCC_APB2ENR_IOPCEN` 是一个宏定义，表示 APB2ENR 寄存器的 **第 4 位**，对应 GPIOC 时钟。通过设置此位为 1 来启用 GPIOC 时钟。

### **常见操作**

#### **1. 启用 GPIO 时钟**
当你想使用 STM32 的某个 GPIO 端口（例如 **GPIOA**, **GPIOB**, **GPIOC** 等），首先需要通过设置 **RCC_APB2ENR** 寄存器来启用相应的 GPIO 时钟：

```c
// 启用 GPIOA、GPIOB 和 GPIOC 的时钟
RCC->APB2ENR |= (RCC_APB2ENR_IOPAEN | RCC_APB2ENR_IOPBEN | RCC_APB2ENR_IOPCEN);
```

#### **2. 启用外设时钟（例如 USART1 或 SPI1）**
例如，如果你想启用 **USART1** 外设来进行串口通信，你可以使用以下代码：

```c
// 启用 USART1 时钟
RCC->APB2ENR |= RCC_APB2ENR_USART1EN;
```



---
<BR><BR><BR>
## **GPIOC_CRH 寄存器**：
在 **STM32** 微控制器中，**GPIOC_CRH** 和 **GPIOC_CRL** 是用于配置 **GPIOC** 端口引脚工作模式的寄存器，它们的全称如下：

1. **GPIOC_CRL**：
   - **全称**：**GPIO Port C Configuration Register Low**（**GPIOC 低位配置寄存器**）
   - **作用**：用于配置 **GPIOC** 端口的 **低位引脚**（**PC0-PC7**）的工作模式和功能。

2. **GPIOC_CRH**：
   - **全称**：**GPIO Port C Configuration Register High**（**GPIOC 高位配置寄存器**）
   - **作用**：用于配置 **GPIOC** 端口的 **高位引脚**（**PC8-PC15**）的工作模式和功能。

### **详细解释**

#### **GPIOC_CRL（低位配置寄存器）**
- 负责控制 **PC0-PC7** 引脚的输入、输出模式配置。
- 每 4 位对应一个引脚，配置该引脚的 **MODE**（输入/输出）和 **CNF**（配置功能）。

| 位范围  | 引脚    | 配置内容       |
|--------|--------|----------------|
| 31:28  | **PC7**  | 配置 PC7 的模式和功能 |
| 27:24  | **PC6**  | 配置 PC6 的模式和功能 |
| 23:20  | **PC5**  | 配置 PC5 的模式和功能 |
| 19:16  | **PC4**  | 配置 PC4 的模式和功能 |
| 15:12  | **PC3**  | 配置 PC3 的模式和功能 |
| 11:8   | **PC2**  | 配置 PC2 的模式和功能 |
| 7:4    | **PC1**  | 配置 PC1 的模式和功能  |
| 3:0    | **PC0**  | 配置 PC0 的模式和功能  |

#### **GPIOC_CRH（高位配置寄存器）**
- 负责控制 **PC8-PC15** 引脚的输入、输出模式配置。
- 同样，每 4 位对应一个引脚，配置 **MODE** 和 **CNF**。

| 位范围  | 引脚    | 配置内容       |
|--------|--------|----------------|
| 31:28  | **PC15** | 配置 PC15 的模式和功能 |
| 27:24  | **PC14** | 配置 PC14 的模式和功能 |
| 23:20  | **PC13** | 配置 PC13 的模式和功能 |
| 19:16  | **PC12** | 配置 PC12 的模式和功能 |
| 15:12  | **PC11** | 配置 PC11 的模式和功能 |
| 11:8   | **PC10** | 配置 PC10 的模式和功能 |
| 7:4    | **PC9**  | 配置 PC9 的模式和功能  |
| 3:0    | **PC8**  | 配置 PC8 的模式和功能  |


- **GPIOC_CRL**：配置 **PC0-PC7** 的模式，低位引脚配置寄存器。
- **GPIOC_CRH**：配置 **PC8-PC15** 的模式，高位引脚配置寄存器。

通过修改这些寄存器的相应位，可以配置每个引脚的工作模式，如输入、输出、推挽输出或开漏输出等。


在 **STM32F103C8T6** 微控制器中，每个 **GPIO 引脚** 的配置由 4 位组成，其中 **2 位** 用于配置 **MODE**（模式，如输入/输出），**2 位** 用于配置 **CNF**（配置功能，如推挽、开漏、上拉等）。

寄存器分为 **GPIO_CRL** 和 **GPIO_CRH**，分别控制低位引脚（PC0-PC7）和高位引脚（PC8-PC15）。每个引脚对应这两个寄存器中的 4 位，通过这 4 位可以设定引脚的具体功能。

### **寄存器位的分配**

每个引脚都有 4 位控制，其中：
- **MODE[1:0]**：用于配置引脚的模式（输入或输出以及输出速度）。
- **CNF[1:0]**：用于配置引脚的功能（推挽、开漏、上拉、下拉等）。

在 **STM32** 的 **GPIO_CRH** 和 **GPIO_CRL** 寄存器中，**MODE[1:0]** 和 **CNF[1:0]** 组合用于配置每个引脚的工作模式和功能。对于每个引脚，配置的顺序是：

- **CNF[1:0]**（功能配置）放在高位（[3:2]），用于设置引脚的功能，如推挽、开漏等。
- **MODE[1:0]**（模式配置）放在低位（[1:0]），用于设置引脚的输入/输出模式或输出速度。

### **排列顺序**

对于每个引脚的 4 位配置，顺序为：

```
[CNF1, CNF0, MODE1, MODE0]
```

### **示例：配置 PC13 为推挽输出模式，输出速度 2 MHz**

- **PC13** 对应 **GPIOC_CRH 寄存器的第 23-20 位**。
  - **MODE13[1:0]**：`10`（输出模式，2 MHz）
  - **CNF13[1:0]**：`00`（推挽输出）

这样，`GPIOC_CRH` 中的 **[23:20]** 位将被设置为 `0010`。



### **MODE 和 CNF 组合设置**

#### **MODE[1:0] 的解释**

| MODE[1:0] | 模式                      |
|-----------|---------------------------|
| 00        | 输入模式（Input mode）     |
| 01        | 输出模式，最大速度 10 MHz  |
| 10        | 输出模式，最大速度 2 MHz   |
| 11        | 输出模式，最大速度 50 MHz  |

#### **CNF[1:0] 的解释**

##### **输入模式下**（MODE = 00）

| CNF[1:0] | 输入模式                    |
|----------|-----------------------------|
| 00       | 模拟输入（Analog mode）      |
| 01       | 浮空输入（Floating input）   |
| 10       | 上拉/下拉输入（Pull-up/Pull-down input） |
| 11       | 复用功能输入（Alternate function input）|

##### **输出模式下**（MODE ≠ 00）

| CNF[1:0] | 输出模式                        |
|----------|---------------------------------|
| 00       | 推挽输出（General purpose output push-pull）  |
| 01       | 开漏输出（General purpose output open-drain） |
| 10       | 复用功能推挽输出（Alternate function output push-pull） |
| 11       | 复用功能开漏输出（Alternate function output open-drain） |

### **示例：配置 PC13 为推挽输出模式，输出速度 2 MHz**

假设你要配置 **PC13** 为 **推挽输出模式**，且输出速度为 **2 MHz**，具体配置步骤如下：

1. **定位引脚**：PC13 是 GPIOC 端口的第 13 个引脚，因此配置位在 **GPIOC_CRH** 寄存器的 **[23:20]** 位（每 4 位对应一个引脚）。
   
2. **设置 MODE 和 CNF**：
   - **MODE[1:0]**：`10`（输出模式，最大速度 2 MHz）
   - **CNF[1:0]**：`00`（推挽输出）

3. **寄存器设置**：

```c
// 启用 GPIOC 时钟
RCC->APB2ENR |= RCC_APB2ENR_IOPCEN;

// 配置 PC13 为 2 MHz 推挽输出模式
GPIOC->CRH &= ~(GPIO_CRH_CNF13);  // 清除 CNF13 位
GPIOC->CRH |= GPIO_CRH_MODE13_1;  // 设置 MODE13 为 2 MHz 输出速度
```


### **下面详细解释代码的含义**

为了清晰展示 **`GPIO_CRH_CNF13`** 和 **`GPIO_CRH_MODE13_1`** 的值，并且结合代码中的位操作，将所有相关掩码的值和寄存器操作的细节列出。

#### 1. **GPIO_CRH 寄存器介绍**

- **GPIO_CRH** 控制 **PC8 到 PC15 引脚** 的配置，每个引脚占用 4 位：2 位用于配置 **CNF**（配置功能），2 位用于配置 **MODE**（模式设置）。
- **PC13** 引脚的配置位在 **GPIO_CRH 的第 23:20 位**，其中：
  - **23:22 位** 是 **CNF13**（配置功能）。
  - **21:20 位** 是 **MODE13**（模式选择：输入/输出速度）。

#### 2. **`GPIO_CRH_CNF13` 和 `GPIO_CRH_MODE13_1` 值**

- **`GPIO_CRH_CNF13`**：表示 PC13 引脚的 **CNF 位**，即 **第 23 和 22 位**。该掩码用于清除这两位的值。
  - **`GPIO_CRH_CNF13 = 0x00C00000`**：二进制表示为 `0000 1100 0000 0000 0000 0000 0000 0000`。
  - **对应的位**：第 23 和 22 位是 `1`，其他位是 `0`。

- **`GPIO_CRH_MODE13_1`**：表示 PC13 引脚的 **MODE 位**（用于设置 2 MHz 输出速度）。它用于设置 **MODE13[1]** 为 `1`，即 **第 21 位** 置为 `1`，**第 20 位** 置为 `0`。
  - **`GPIO_CRH_MODE13_1 = 0x00200000`**：二进制表示为 `0000 0010 0000 0000 0000 0000 0000 0000`。
  - **对应的位**：第 21 位是 `1`，第 20 位是 `0`。

#### 3. **操作步骤与结果**

#### **（1）初始状态**

**GPIO_CRH** 寄存器初始状态未知。我们只关心 **PC13 对应的 4 位**（即 23-20 位）。假设初始值为随机值 `X`：

| 位号     | 23    | 22    | 21    | 20    | 描述                                |
|----------|-------|-------|-------|-------|-------------------------------------|
| 初始值   | X     | X     | X     | X     | 未配置                              |

#### **（2）`GPIOC->CRH &= ~(GPIO_CRH_CNF13);`**

这行代码清除 **CNF13**，即 **第 23 和 22 位**，将这两个位设置为 `00`（推挽输出模式）。

操作：
```c
GPIOC->CRH &= ~(GPIO_CRH_CNF13);  // 清除 CNF13 位
```

掩码：
- **`GPIO_CRH_CNF13 = 0x00C00000`**：用于清除第 23 和 22 位。
- **`~(GPIO_CRH_CNF13) = 0xFF3FFFFF`**：清除第 23 和 22 位，其他位不变。

执行此行代码后，寄存器的 **23 和 22 位** 被清零，配置为 `00`（推挽输出），其他位保持不变。

| 位号     | 23    | 22    | 21    | 20    | 描述                                |
|----------|-------|-------|-------|-------|-------------------------------------|
| 修改后   | 0     | 0     | X     | X     | CNF13 被清除为 `00`（推挽输出模式） |

#### **（3）`GPIOC->CRH |= GPIO_CRH_MODE13_1;`**

这行代码设置 **MODE13[1]**，即 **第 21 位** 为 `1`，设置 **MODE13** 为 `10`，对应 **2 MHz 输出速度**。

操作：
```c
GPIOC->CRH |= GPIO_CRH_MODE13_1;  // 设置 MODE13 为 2 MHz 输出速度
```

掩码：
- **`GPIO_CRH_MODE13_1 = 0x00200000`**：用于设置第 21 位为 `1`，第 20 位为 `0`。

执行此行代码后，寄存器的 **21 和 20 位**被设置为 `10`，即 2 MHz 输出速度。

| 位号     | 23    | 22    | 21    | 20    | 描述                                |
|----------|-------|-------|-------|-------|-------------------------------------|
| 修改后   | 0     | 0     | 1     | 0     | MODE13 设置为 `10`（2 MHz 输出）    |

### **4. 总结表格**

| 操作步骤                                  |23 |22 |21 |20 | 描述                                   |
|-------------------------------------------|---------|---------|---------|---------|----------------------------------------|
| 初始状态                                  | X       | X       | X       | X       | 未配置                                 |
| GPIOC->CRH &= ~(GPIO_CRH_CNF13)          | 0       | 0       | X       | X       | CNF13 被清除为 `00`（推挽输出模式）    |
| GPIOC->CRH \\|= GPIO_CRH_MODE13_1          | 0       | 0       | 1       | 0       | MODE13 设置为 `10`（2 MHz 输出速度）   |

### **最终寄存器配置结果：**

- **CNF13[1:0] = 00**：配置为推挽输出模式。
- **MODE13[1:0] = 10**：配置为 2 MHz 输出速度。

通过这两行代码，**PC13 引脚**成功被配置为 **2 MHz 的推挽输出模式**，用于控制诸如板载 LED 之类的外设。

---
<BR><BR><BR>
### **GPIOC_BSRR 寄存器**：
**`GPIOC_BSRR`** 的全称是 **GPIO Port C Bit Set/Reset Register**，中文译作 **GPIO C 端口位设置/复位寄存器**。

- **GPIO**：表示 **通用输入/输出端口**（General Purpose Input/Output）。
- **Port C**：表示该寄存器对应 **GPIOC 端口**，即 **C 端口的引脚**。
- **Bit Set/Reset**：表示该寄存器用于 **位设置/复位**，可以通过对某一位的写入操作来 **设置引脚为高电平** 或 **复位引脚为低电平**。
- **Register**：表示该寄存器用于控制相应的硬件引脚。

### **`GPIO_BSRR_BR13` 和 `GPIO_BSRR_BS13` 的全称：**

1. **`GPIO_BSRR_BR13`**：
   - **全称**：**GPIO Port Bit Reset Register, Bit Reset for Pin 13**
   - **中文**：**GPIO 端口位复位寄存器，复位第 13 引脚**
   - **含义**：表示复位 **GPIO 端口 13 号引脚**（BR13），即将引脚设置为 **低电平**。
   ```c
   #define GPIO_BSRR_BR13                       ((uint32_t)0x20000000)
   ```

2. **`GPIO_BSRR_BS13`**：
   - **全称**：**GPIO Port Bit Set Register, Bit Set for Pin 13**
   - **中文**：**GPIO 端口位设置寄存器，设置第 13 引脚**
   - **含义**：表示设置 **GPIO 端口 13 号引脚**（BS13），即将引脚设置为 **高电平**。
    ```c
    #define GPIO_BSRR_BS13                       ((uint32_t)0x00002000)
    ```

它们是控制 **GPIOC_BSRR 寄存器**中与 PC13 引脚相关的两个位的宏定义。

下面解释 `GPIO_BSRR_BR13` 和 `GPIO_BSRR_BS13` 在 `GPIOC_BSRR` 寄存器中的作用。

### **1. GPIOC_BSRR 寄存器概述**

`GPIOC_BSRR` 是一个 32 位寄存器，分为两个部分：

- **低 16 位（0-15 位）**：用于设置对应的引脚为 **高电平**。每一位对应一个 GPIO 引脚，写 `1` 时，相应引脚设置为 **高电平**。
- **高 16 位（16-31 位）**：用于复位对应的引脚为 **低电平**。每一位对应一个 GPIO 引脚，写 `1` 时，相应引脚复位为 **低电平**。

#### **寄存器结构表**

| 位号    | 31  | 30  | 29  | 28  | ... | 17  | 16  | 15  | 14  | 13  | 12  | ... | 1   | 0   |
|---------|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|
| 含义    | BR15| BR14| **BR13**| BR12| ... | BR1 | BR0 | BS15| BS14| **BS13**| BS12| ... | BS1 | BS0 |

- **BSx**（低 16 位）：用于将 GPIO 引脚置为 **高电平**。
- **BRx**（高 16 位）：用于将 GPIO 引脚复位为 **低电平**。

### **2. `GPIO_BSRR_BR13` 和 `GPIO_BSRR_BS13` 的具体值**

#### **`GPIO_BSRR_BR13`**
- 这是一个宏，代表 **BR13 位**，对应 **GPIOC_BSRR 寄存器**的 **第 29 位**（用于复位 PC13 为低电平）。
- **值**：`(1 << (13 + 16)) = 0x20000000`，即将 **第 29 位** 置为 `1`，用于将 **PC13 引脚**复位为 **低电平**。

#### **`GPIO_BSRR_BS13`**
- 这是一个宏，代表 **BS13 位**，对应 **GPIOC_BSRR 寄存器**的 **第 13 位**（用于设置 PC13 为高电平）。
- **值**：`(1 << 13) = 0x00002000`，即将 **第 13 位** 置为 `1`，用于将 **PC13 引脚**设置为 **高电平**。

### **3. 结合代码解释**

#### **代码片段：**

```c
// 3. 点亮 LED（将 PC13 置为低电平）
GPIOC->BSRR = GPIO_BSRR_BR13;    // 设置 BR13 位，将 PC13 置为低电平
delay(500000);                   // 延时

// 4. 熄灭 LED（将 PC13 置为高电平）
GPIOC->BSRR = GPIO_BSRR_BS13;    // 设置 BS13 位，将 PC13 置为高电平
delay(500000);                   // 延时
```

#### **点亮 LED：将 PC13 设置为低电平**
```c
GPIOC->BSRR = GPIO_BSRR_BR13;    // 设置 BR13 位，将 PC13 置为低电平
```

- **`GPIO_BSRR_BR13 = 0x20000000`**，对应 **GPIOC_BSRR 的第 29 位**。
- 写入 `1` 到 **BR13**（即第 29 位），表示复位 PC13（即将 PC13 置为低电平）。

- **效果**：
  - PC13 引脚输出低电平。如果板载 LED 是低电平点亮的，那么此时 LED 将被点亮。

#### **延时**
```c
delay(500000);  // 延时
```
- 用于保持 LED 点亮一段时间。

#### **熄灭 LED：将 PC13 设置为高电平**
```c
GPIOC->BSRR = GPIO_BSRR_BS13;    // 设置 BS13 位，将 PC13 置为高电平
```

- **`GPIO_BSRR_BS13 = 0x00002000`**，对应 **GPIOC_BSRR 的第 13 位**。
- 写入 `1` 到 **BS13**（即第 13 位），表示设置 PC13 为高电平。

- **效果**：
  - PC13 引脚输出高电平。如果板载 LED 是低电平点亮的，那么此时 LED 将熄灭。

#### **延时**
```c
delay(500000);  // 延时
```
- 用于保持 LED 熄灭一段时间。

### **4. 表格表示操作步骤**

| 操作步骤                                  | BSRR 寄存器值                | 描述                                                         |
|-------------------------------------------|------------------------------|--------------------------------------------------------------|
| **点亮 LED**（写入 `GPIO_BSRR_BR13`）     | `0x20000000` （第 29 位）     | 设置 **BR13 位**，将 PC13 置为 **低电平**，点亮 LED          |
| **延时**                                  | N/A                          | 延时，保持 LED 点亮状态                                      |
| **熄灭 LED**（写入 `GPIO_BSRR_BS13`）     | `0x00002000` （第 13 位）     | 设置 **BS13 位**，将 PC13 置为 **高电平**，熄灭 LED          |
| **延时**                                  | N/A                          | 延时，保持 LED 熄灭状态                                      |

### **5. 寄存器值的详细表示**

#### **第一次写入（点亮 LED）**
- **`GPIOC->BSRR = GPIO_BSRR_BR13`**
- **写入 0x20000000 到 GPIOC_BSRR**，即将第 29 位（BR13）置为 `1`，将 PC13 置为低电平。

| 位号        | 31  | 30  | **29**  | 28  | 27  | ... | 17  | 16  | 15  | 14  | **13**  | 12  | ... |
|-------------|-----|-----|--------|-----|-----|-----|-----|-----|-----|-----|--------|-----|-----|
| 值          | 0   | 0   | **1**  | 0   | 0   | ... | 0   | 0   | 0   | 0   | **0**  | 0   | ... |

#### **第二次写入（熄灭 LED）**
- **`GPIOC->BSRR = GPIO_BSRR_BS13`**
- **写入 0x00002000 到 GPIOC_BSRR**，即将第 13 位（BS13）置为 `1`，将 PC13 置为高电平。

| 位号        | 31  | 30  | **29**  | 28  | 27  | ... | 17  | 16  | 15  | 14  | **13**  | 12  | ... |
|-------------|-----|-----|--------|-----|-----|-----|-----|-----|-----|-----|--------|-----|-----|
| 值          | 0   | 0   | **0**  | 0   | 0   | ... | 0   | 0   | 0   | 0   | **1**  | 0   | ... |

### **6. 总结**

通过 **GPIOC_BSRR**，你可以高效地设置或复位 **PC13 引脚**的电平：

- **点亮 LED**：写入 `GPIO_BSRR_BR13 = 0x20000000`，将 **PC13** 置为 **低电平**。
- **熄灭 LED**：写入 `GPIO_BSRR_BS13 = 0x00002000`，将 **PC13** 置为 **高电平**。

这种操作保证了寄存器的原子性，使得 GPIO 引脚的电平设置和复位可以通过单次写操作完成，而无需先读取再修改。

