---
layout: post
title:  "CAN"
categories: embed
---

**CAN（Controller Area Network，控制器局域网）** 是一种常用于工业自动化、汽车电子等领域的通信协议，它具有高可靠性、实时性强和抗干扰能力强的特点。CAN 通信广泛应用于 **汽车电子控制系统**（如引擎控制单元、气囊控制单元、车身控制模块等）、**工业自动化设备** 以及 **嵌入式系统** 中的节点之间的数据通信。

### **CAN 通信的基本概念**

CAN 是一种 **多主通信协议**，即网络中的每个节点（设备）都可以主动发送消息，不需要单独的主控制器。CAN 总线是一种 **多点传输** 的方式，所有的节点都连接到同一条总线上，消息通过总线广播，每个节点根据消息的标识符（ID）决定是否接收和处理该消息。

#### **CAN 的关键特性**：
1. **多主通信**：
   - CAN 网络中的任意节点可以主动发送消息，而不是单纯依赖一个主设备控制通信。
   
2. **消息优先级**：
   - CAN 的每条消息都有一个 **标识符（ID）**，它不仅用于区分不同类型的消息，还定义了消息的优先级。ID 越低的消息优先级越高，能够优先占用总线。

3. **差分信号和抗干扰**：
   - CAN 总线采用 **差分信号传输**（CAN_H 和 CAN_L），通过两个电平的差值传输数据，这种方式对电磁干扰有很强的抵抗能力，适合在噪声较多的工业环境中使用。

4. **错误检测和纠正机制**：
   - CAN 内置多种 **错误检测机制**，如位填充、CRC 校验、应答错误和格式错误等。遇到传输错误时，CAN 控制器会自动重发数据，并且能够通过这些机制确保数据传输的可靠性。

5. **实时性**：
   - CAN 设计为一种实时协议，非常适合需要高实时性、快速响应的应用场景，如汽车中的引擎控制、制动系统等。

6. **传输速率**：
   - CAN 支持的最高通信速率为 **1 Mbps**，并且能够在数百米的距离内保持高可靠性和稳定性。在传输距离较短时（如 40 米以内），可以达到 1 Mbps 的速率，但如果传输距离加长，通信速率则需要降低。

### **CAN 在 STM32 中的实现**

STM32 微控制器集成了 **CAN 控制器**，支持 CAN 协议的完整实现。STM32 的 CAN 外设能够独立管理数据帧的发送和接收，且支持多种滤波机制来处理大量的消息。

#### **STM32 CAN 的工作模式**：
1. **正常模式（Normal Mode）**：用于标准 CAN 通信，节点可发送和接收消息。
2. **环回模式（Loopback Mode）**：用于测试目的，节点在内部自环回发送的消息，用于调试时不需要连接物理总线。
3. **静默模式（Silent Mode）**：节点可以接收总线上的数据，但不发送数据。用于被动监视总线的通信。
4. **环回 + 静默模式（Loopback + Silent Mode）**：结合环回和静默模式，仅用于内部测试通信，不影响总线。

### **CAN 数据帧结构**

CAN 消息由多个字段组成，以下是 CAN 标准帧（11 位标识符）格式的主要字段：
1. **标识符（ID）**：用于标识消息类型和优先级，11 位（标准帧）或 29 位（扩展帧）。
2. **RTR 位**：远程传输请求位，用于请求远程节点的数据。
3. **控制字段**：定义消息类型（数据帧、远程帧）和数据长度。
4. **数据字段**：包含实际传输的数据，最大为 8 字节。
5. **CRC 校验**：用于检测数据的完整性。
6. **应答位（ACK）**：接收方使用 ACK 位通知发送方消息是否成功接收。

### **STM32 中 CAN 的引脚和硬件连接**

STM32 的 CAN 外设通过特定的引脚与 CAN 收发器（**CAN Transceiver**）连接，CAN 收发器用于将 STM32 的逻辑信号转换为 CAN 总线信号（差分信号）以供 CAN 总线传输。

- **CAN_TX**：CAN 控制器的发送引脚，连接到收发器的 TX 引脚。
- **CAN_RX**：CAN 控制器的接收引脚，连接到收发器的 RX 引脚。
- **CAN_H** 和 **CAN_L**：CAN 收发器的差分信号输出引脚，连接到 CAN 总线的高电平（CAN_H）和低电平（CAN_L）信号线。

在实际使用中，STM32 通常需要通过外部 **CAN 收发器芯片**（如 **MCP2551** 或 **TJA1050**）连接到 CAN 总线。STM32 内部只提供 CAN 控制器，而 CAN 收发器负责将逻辑电平信号转换为总线上的差分信号。

### **STM32 CAN 配置和使用示例**

以下是使用 **STM32CubeMX** 和 HAL 库在 STM32 上配置 CAN 外设，并发送和接收 CAN 消息的简单示例。

#### **1. 使用 STM32CubeMX 配置 CAN 外设**

1. 打开 **STM32CubeMX**，选择目标芯片（如 **STM32F103C8T6**）。
2. 在 **Peripherals** 栏目中，启用 **CAN1** 外设，并配置 CAN_TX 和 CAN_RX 引脚。
3. 配置 CAN 的波特率、滤波器等参数。波特率通常设置为 **500 kbps** 或 **1 Mbps**，具体取决于应用需求。
4. 生成代码，并在 **STM32CubeIDE** 中打开项目。

#### **2. 初始化 CAN**

在生成的代码中，通过 `MX_CAN_Init()` 函数初始化 CAN 外设。

```c
#include "main.h"
#include "can.h"

CAN_HandleTypeDef hcan;

// CAN 初始化函数
void MX_CAN_Init(void) {
    hcan.Instance = CAN1;
    hcan.Init.Prescaler = 16;  // 分频系数，决定波特率
    hcan.Init.Mode = CAN_MODE_NORMAL;  // 设置为正常模式
    hcan.Init.SyncJumpWidth = CAN_SJW_1TQ;
    hcan.Init.TimeSeg1 = CAN_BS1_8TQ;
    hcan.Init.TimeSeg2 = CAN_BS2_1TQ;
    hcan.Init.AutoBusOff = DISABLE;
    hcan.Init.AutoWakeUp = DISABLE;
    hcan.Init.AutoRetransmission = ENABLE;
    hcan.Init.ReceiveFifoLocked = DISABLE;
    hcan.Init.TransmitFifoPriority = DISABLE;
    if (HAL_CAN_Init(&hcan) != HAL_OK) {
        // 初始化失败处理
        Error_Handler();
    }
}
```

#### **3. 配置 CAN 滤波器**

CAN 的滤波器用于过滤不需要的消息，只有通过滤波器的消息才会进入接收队列。这里我们设置为接收所有消息。

```c
void CAN_Filter_Config(void) {
    CAN_FilterTypeDef can_filter;
    
    can_filter.FilterBank = 0;  // 选择过滤器
    can_filter.FilterMode = CAN_FILTERMODE_IDMASK;  // 掩码模式
    can_filter.FilterScale = CAN_FILTERSCALE_32BIT;  // 32位过滤器
    can_filter.FilterIdHigh = 0x0000;  // 接收所有ID
    can_filter.FilterIdLow = 0x0000;
    can_filter.FilterMaskIdHigh = 0x0000;
    can_filter.FilterMaskIdLow = 0x0000;
    can_filter.FilterFIFOAssignment = CAN_RX_FIFO0;
    can_filter.FilterActivation = ENABLE;
    HAL_CAN_ConfigFilter(&hcan, &can_filter);  // 配置过滤器
}
```

#### **4. 发送 CAN 消息**

以下代码演示了如何发送一条标准的 CAN 消息（11 位标识符）。

```c
void CAN_Send_Message(uint16_t id, uint8_t *data, uint8_t len) {
    CAN_TxHeaderTypeDef tx_header;
    uint32_t tx_mailbox;
    uint8_t tx_data[8];

    tx_header.StdId = id;  // 11位标识符
    tx_header.ExtId = 0x00;  // 不使用扩展标识符
    tx_header.RTR = CAN_RTR_DATA;  // 数据帧
    tx_header.IDE = CAN_ID_STD;  // 使用标准帧
    tx_header.DLC = len;  // 数据长度
    tx_header.TransmitGlobalTime = DISABLE;

    memcpy(tx_data, data, len

);

    if (HAL_CAN_AddTxMessage(&hcan, &tx_header, tx_data, &tx_mailbox) != HAL_OK) {
        // 发送失败处理
        Error_Handler();
    }
}
```

#### **5. 接收 CAN 消息**

CAN 消息接收可以通过中断或轮询方式实现。下面是通过中断方式接收 CAN 消息的代码。

```c
void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan) {
    CAN_RxHeaderTypeDef rx_header;
    uint8_t rx_data[8];

    // 从接收队列读取消息
    if (HAL_CAN_GetRxMessage(hcan, CAN_RX_FIFO0, &rx_header, rx_data) == HAL_OK) {
        // 处理接收到的数据
    }
}

// 开启接收中断
HAL_CAN_ActivateNotification(&hcan, CAN_IT_RX_FIFO0_MSG_PENDING);
```

### **CAN 的应用场景**

1. **汽车电子**：
   - CAN 总线是汽车电子系统中的标准通信协议，用于引擎控制、传感器监控、车身控制模块之间的通信。CAN 具有实时性强、抗干扰能力强的特点，适合在汽车复杂的电气环境中使用。

2. **工业自动化**：
   - 在工业控制系统中，CAN 总线用于机器和设备之间的数据传输。CAN 的高可靠性和数据完整性，使其成为工业自动化、分布式控制系统的重要通信方式。

3. **电梯控制系统**：
   - CAN 常用于电梯系统中的传感器、控制器和显示器之间的数据交换，确保系统的可靠性和安全性。

4. **机器人系统**：
   - 在机器人系统中，CAN 可用于各个传感器、执行器之间的实时通信，支持高效的运动控制和状态监控。

### **CAN 常见问题**

1. **波特率不匹配**：
   - CAN 网络中所有节点的波特率必须一致。如果某个节点波特率设置错误，会导致该节点无法参与通信或导致通信错误。

2. **消息丢失或传输失败**：
   - CAN 总线存在优先级机制，如果总线负载过高，优先级较低的消息可能被延迟或丢失。

3. **滤波器配置错误**：
   - 如果 CAN 滤波器配置不当，可能会导致部分消息未被接收，需要检查滤波器设置是否正确。

### **总结**

- **CAN（控制器局域网）** 是一种常用于汽车、工业自动化、机器人等嵌入式系统中的通信协议，具有实时性强、抗干扰能力强的特点。
- STM32 微控制器内置 **CAN 控制器**，支持 CAN 的发送、接收和消息过滤功能，并通过外部 CAN 收发器连接到物理 CAN 总线。
- STM32 的 CAN 模块可用于多种应用场景，如汽车控制系统、工业设备控制、传感器网络等，并且可以通过 STM32CubeMX 和 HAL 库轻松配置和使用。