---
layout: post
title:  "给定两个正整数a,b请求出区间[a,b]内的质数之和并输出"
categories: question
---

<script src="https://cdnjs.cloudflare.com/ajax/libs/core-js/3.6.5/minified.js"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

---

#### 给定两个正整数a,b请求出区间[a,b]内的质数之和并输出。⼀种常⻅的判断⼀个数是否为质数的算法：根号范围遍历。利⽤合数定理⸺如果⼀个数是合数，那么它的最质因数肯定⼩于等于他的平⽅根.  

输⼊格式：两个正整数 a , b  
输出格式：⼀个正整数，即区间[a,b]内的质数之和。  
数据范围：1 ≤ a ≤ 10000 ,a ≤ b ≤ 10000  

--- 
<BR><BR><BR><BR>

判断一个数是否为质数的常见算法之一是**根号范围遍历**，基于合数定理：**如果一个数是合数，那么它的最小质因数肯定小于等于它的平方根**。该算法通过减少需要检查的范围，提高了判断质数的效率。

### 算法思路
- **质数**定义：质数是大于 1 的自然数，除了 1 和它本身以外没有其他的因数。
- **合数**定义：合数是指除了 1 和它本身外，还有其他因数的自然数。

根据合数定理，如果一个数 \( n \) 是合数，则它的最小质因数一定小于等于 $$ ( \sqrt{n} ) $$。因此，在判断一个数是否为质数时，我们只需检查它是否能被小于等于它平方根的数整除。如果没有任何因数能整除它，那么该数就是质数。

### 具体步骤
1. 如果数 $$ ( n \leq 1 ) $$，则不是质数。
2. 检查 \( n \) 是否能被 2 整除。如果能且 \( n > 2 \)，则不是质数。
3. 通过遍历从 3 到 $$ ( \sqrt{n} ) $$ 之间的所有奇数，检查是否有数能整除 \( n \)。
4. 如果没有找到可以整除的数，说明 \( n \) 是质数。

### C 语言实现
```c
#include <stdio.h>
#include <math.h>  // 包含sqrt函数

// 判断一个数是否为质数
int isPrime(int n) {
    if (n <= 1) return 0;  // 小于等于1的数不是质数
    if (n == 2) return 1;  // 2是质数
    if (n % 2 == 0) return 0;  // 偶数大于2的数不是质数

    int sqrt_n = (int)sqrt(n);  // 计算n的平方根

    // 从3开始遍历到sqrt(n)，步长为2，跳过偶数
    for (int i = 3; i <= sqrt_n; i += 2) {
        if (n % i == 0) {
            return 0;  // 如果找到因数，说明n不是质数
        }
    }
    return 1;  // 没有找到因数，说明n是质数
}

```

### 代码说明：
1. **`isPrime` 函数**：
   - 如果输入小于等于 1，则返回 0（不是质数）。
   - 特殊处理 2，因为 2 是唯一的偶数质数。
   - 使用 `sqrt(n)` 函数计算 \( n \) 的平方根，并只遍历 3 到平方根之间的所有奇数。
   - 如果找到一个因数可以整除 \( n \)，立即返回 0（表示不是质数）。

2. **性能优化**：
   - 通过仅检查到 $$ ( \sqrt{n} ) $$，大大减少了需要遍历的数字数量，优化了判断质数的性能。
   - 通过跳过所有偶数，减少了不必要的计算。

### 示例：
输入 `29` 时，输出：
```
29 是质数
```

输入 `30` 时，输出：
```
30 不是质数
```

### 复杂度分析：
- 该算法的时间复杂度是 $$ ( O(\sqrt{n}) )$$，因为我们只遍历到 \( n \) 的平方根。相比于直接遍历 \( n \) 之前的所有数，这种方式更高效。

---

<BR><BR><BR>

给定两个正整数a,b请求出区间[a,b]内的质数之和并输出
要解决这个问题，首先需要计算两个正整数区间 \([a, b]\) 内的所有质数，然后求出这些质数的和并输出。为了实现这个功能，我们可以分成以下几个步骤：

1. **质数判断**：我们可以使用之前提到的**根号范围遍历法**来判断一个数是否为质数。
2. **遍历区间 [a, b]**：对区间内的所有数进行质数判断。
3. **累加质数**：如果当前数是质数，则将其加入到总和中。

### C 语言实现

```c
#include <stdio.h>
#include <math.h>

// 判断一个数是否为质数
int isPrime(int n) {
    if (n <= 1) return 0;  // 小于等于1的数不是质数
    if (n == 2) return 1;  // 2是质数
    if (n % 2 == 0) return 0;  // 偶数大于2的数不是质数

    int sqrt_n = (int)sqrt(n);  // 计算n的平方根

    // 从3开始遍历到sqrt(n)，步长为2，跳过偶数
    for (int i = 3; i <= sqrt_n; i += 2) {
        if (n % i == 0) {
            return 0;  // 如果找到因数，说明n不是质数
        }
    }
    return 1;  // 没有找到因数，说明n是质数
}

// 求区间[a, b]内的质数之和
int prime_sum(int a, int b) {
    int sum = 0;
    for (int i = a; i <= b; i++) {
        if (isPrime(i)) {
            sum += i;  // 如果是质数，累加到sum中
        }
    }
    return sum;
}

int main() {
    int a, b;
    printf("请输入区间[a, b]: ");
    scanf("%d %d", &a, &b);

    int result = prime_sum(a, b);
    printf("区间 [%d, %d] 内质数的和为: %d\n", a, b, result);

    return 0;
}
```

### 代码说明：

1. **`isPrime` 函数**：
   - 使用平方根优化的质数判断方法，检查数字是否为质数。
   - 如果输入 \( n \leq 1 \)，返回 0 表示不是质数。
   - 特殊处理 2，因为 2 是唯一的偶数质数。
   - 对于大于 2 的奇数，通过从 3 开始到 \( \sqrt{n} \) 的数进行遍历检查是否有因数。

2. **`prime_sum` 函数**：
   - 遍历区间 \([a, b]\) 内的所有数，并对每个数调用 `isPrime` 函数判断是否为质数。
   - 如果是质数，则将其加到 `sum` 中。
   - 最终返回所有质数的和。

3. **`main` 函数**：
   - 用户输入区间 \([a, b]\)，调用 `prime_sum` 函数计算质数之和并输出。

### 示例：

- 输入：
  ```
  请输入区间[a, b]: 10 20
  ```
  输出：
  ```
  区间 [10, 20] 内质数的和为: 60
  ```

  其中，区间 [10, 20] 内的质数为：11, 13, 17, 19，它们的和是 60。

### 复杂度分析：
- 对每个数进行质数判断的时间复杂度是 $$ (O(\sqrt{n})) $$。
- 遍历区间 \([a, b]\) 的总时间复杂度是 $$ (O((b - a + 1) \times \sqrt{b})) $$，这对中等大小的输入是可以接受的。

这个程序可以很有效地计算给定区间内的质数之和。