---
layout: post
title:  "⼗进制转⼆进制"
categories: question
---

<script src="https://cdnjs.cloudflare.com/ajax/libs/core-js/3.6.5/minified.js"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>



⼗进制转⼆进制的除法取余法源自于二进制系统的结构和特点。在计算机科学中，二进制表示法是最基础的表示法，数字仅使用两个符号：0 和 1。转换的核心思想来自如何通过逐步减少十进制数，找到它在二进制系统中的每一位。这个过程可以通过以下逻辑推导出：

### 1. 二进制的基本概念
二进制是基于2的进位制，每一位的权值是2的幂次，比如：
- 第一位（从右到左）表示 \(2^0 = 1\)
- 第二位表示 \(2^1 = 2\)
- 第三位表示 \(2^2 = 4\)
- 以此类推。

每个十进制数在二进制表示中，实际上是将它分解成不同的 2 的幂的组合。例如，十进制的 10 可以表示为：  

$$ 10 = 1 \times 2^3 + 0 \times 2^2 + 1 \times 2^1 + 0 \times 2^0 $$


其二进制表示为 1010。

### 2. 除法取余法的推导
为了找出某个十进制数的二进制表示，我们可以使用“除法取余法”来逐步确定二进制的每一位：
- **核心思想**：二进制每一位的值（0 或 1）可以通过不断对十进制数进行“除以2”操作得到。
  - 每次除以 2 后，商表示更新后的十进制数，余数表示当前位的二进制值。
  - 这个余数不是别的，就是该十进制数在这个位置上的“二进制位”值。

**步骤如下**：
1. 对十进制数进行除以 2，得到的余数是二进制的最后一位（即最低位）。
2. 将商作为下一个十进制数继续除以 2，得到的余数是倒数第二位。
3. 不断重复这个过程，直到商为 0。此时所有的余数就是该数的二进制位，按逆序排列即可得到二进制结果。

### 3. 为什么用除法？
通过除以2，可以逐步减少十进制数，且余数是 0 或 1，恰好与二进制系统中的位值对应。每次的余数决定了当前二进制位是 0 还是 1，而商则决定了接下来需要处理的十进制数。这种逐步划分的过程，最终将每一位都分离出来。

#### 举个例子：
转换十进制数 10 为二进制：
1. 10 ÷ 2 = 5，余数 0（表示最低位）。
2. 5 ÷ 2 = 2，余数 1（表示次低位）。
3. 2 ÷ 2 = 1，余数 0（表示第三位）。
4. 1 ÷ 2 = 0，余数 1（表示最高位）。

因此，按照从后往前的顺序，10 的二进制表示为 1010。

### 总结
“除法取余法”其实是利用了二进制数的本质特性，即每一位是 0 或 1，通过除以 2 来逐步分解十进制数并找出每个位置上的值。该方法是一种简单且有效的方式，可以方便地将十进制数转换为二进制。

<br><br><br><br><br><br>


---
## C 语言实现  

⼗进制转⼆进制的除法取余法是计算机科学中常⽤的⼀种算法，它通过不断地将⼗进制数除以 2，保存余数，直到商为 0。余数的逆序排列即为对应的⼆进制数。

以下是该算法的 C 语言实现：

```c
#include <stdio.h>

void decimalToBinary(int n) {
    int binaryNum[32] = {0};
    int i = 0;

    // 使用除法取余法计算二进制
    while (n > 0) {
        binaryNum[i] = n % 2;  // 保存余数
        n = n / 2;             // 更新商
        i++;                   // 更行最高位index, base 0
    }

    // 逆序输出二进制结果
    printf("二进制表示为: ");
    for (int j = i - 1; j >= 0; j--) {
        printf("%d", binaryNum[j]);
    }
    printf("\n");
}

int main() {
    int n;
    printf("请输入一个十进制数: ");
    scanf("%d", &n);
    decimalToBinary(n);
    return 0;
}
```

### 代码说明：
1. `decimalToBinary(int n)`函数通过除法取余法将十进制数转换为二进制。
2. `binaryNum`数组用于存储每次除以 2 后的余数。
3. 最终通过逆序输出存储在数组中的余数，得到二进制表示。

### 示例：
若输入 `n = 10`，输出为 `1010`。

这是将十进制数转换为二进制的基本算法实现。
<br><br><br><br><br><br>

---

## 如果是负数怎么办？

十进制转二进制的**除法取余法**对负数直接无效。因为这个方法是基于逐次除以 2 并获取余数的过程，而这个过程是专门针对正整数设计的。对于负数来说，直接使用该方法并不能得到正确的二进制表示。

### 为什么除法取余法对负数无效？

在除法取余法中，我们通过不断地将正数除以 2 来获取余数，并从低位到高位构建二进制表示。但对于负数，情况不同，因为负数在计算机中的存储使用的是**补码**，而不是简单的符号加上绝对值的二进制形式。

因此，直接使用除法取余法会得到错误的结果。例如，使用该方法对 -10 进行转换，会导致无法正确处理符号位，得到的并不是补码表示。

### 对负数有效的方法

要处理负数，应该首先将其转化为**补码**形式，而补码可以通过以下步骤计算：
1. 将负数的绝对值按正常的除法取余法转换为二进制。
2. 对结果进行**取反**（即将 0 变 1，1 变 0）。
3. **加 1**，得到最终的补码表示。

### 使用 C 语言处理负数的二进制表示
在 C 语言中，负数已经以补码形式存储，所以你可以直接通过位操作来输出负数的补码表示。

```c
#include <stdio.h>

// 输出一个整数的二进制表示
void printBinary(int n) {
    unsigned int mask = 1 << 31;  // 32位系统，最高位的掩码为 1 << 31
    for (int i = 0; i < 32; i++) {
        // 检查当前位是否为1，并打印
        if (n & mask)
            printf("1");
        else
            printf("0");
        // 将掩码右移一位
        mask >>= 1;

        // 每四位加一个空格，便于阅读
        if ((i + 1) % 4 == 0)
            printf(" ");
    }
    printf("\n");
}

int main() {
    int n;
    printf("请输入一个十进制数: ");
    scanf("%d", &n);
    printf("二进制表示为: ");
    printBinary(n);
    return 0;
}
```

这个程序通过位操作实现了将十进制数转换为二进制并输出的功能，无论输入的是正数还是负数，它都可以正确输出其在计算机中存储的二进制表示。

### 代码运行流程解析：
1. **定义掩码**：
   - 使用 `unsigned int mask = 1 << 31;`，初始化掩码为最高位为1，其他位为0，即 `10000000 00000000 00000000 00000000`（假设系统为 32 位）。
   - 然后通过逐位右移掩码，每次检查整数 `n` 在当前位上的值。

2. **通过 `n & mask` 检查每一位是否为 1**：
   - 逐位与掩码 `mask` 进行按位与操作，如果当前位为1，则输出 `1`，否则输出 `0`。
   - 掩码每次右移一位，逐步检查从最高位到最低位的每一位。

3. **每四位加一个空格**：
   - 通过 `(i + 1) % 4 == 0` 判断当前是第几位，每四位输出一个空格，便于阅读输出结果。

### 代码示例：
输入 `10` 时，输出结果为：
```
00000000 00000000 00000000 00001010
```

输入 `-10` 时，输出结果为：
```
11111111 11111111 11111111 11110110
```
这里，`-10` 的输出是以补码形式表示的，即在计算机中的实际存储方式。

### 补充说明：
- C 语言中，整数 `n` 是有符号整数类型 `int`，无论是正数还是负数，二进制都以补码的形式表示。
- `unsigned int` 用来确保掩码操作不会受到符号位的影响，因为对于位操作，符号位的存在可能会导致一些不期望的结果。


### 总结：
该程序通过位操作实现了十进制到二进制的转换，能够处理正数和负数，并以补码形式输出负数。程序中的位操作是高效且通用的，可以适应不同的整型数值。